"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgeneral_interface"] = self["webpackChunkgeneral_interface"] || []).push([["vendors-node_modules_dimforge_rapier2d_rapier_js"],{

/***/ "./node_modules/@dimforge/rapier2d/coarena.js":
/*!****************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/coarena.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coarena: () => (/* binding */ Coarena)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Coarena = /*#__PURE__*/function () {\n  function Coarena() {\n    _classCallCheck(this, Coarena);\n    this.fconv = new Float64Array(1);\n    this.uconv = new Uint32Array(this.fconv.buffer);\n    this.data = new Array();\n    this.size = 0;\n  }\n  _createClass(Coarena, [{\n    key: \"set\",\n    value: function set(handle, data) {\n      var i = this.index(handle);\n      while (this.data.length <= i) {\n        this.data.push(null);\n      }\n      if (this.data[i] == null) this.size += 1;\n      this.data[i] = data;\n    }\n  }, {\n    key: \"len\",\n    value: function len() {\n      return this.size;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(handle) {\n      var i = this.index(handle);\n      if (i < this.data.length) {\n        if (this.data[i] != null) this.size -= 1;\n        this.data[i] = null;\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.data = new Array();\n    }\n  }, {\n    key: \"get\",\n    value: function get(handle) {\n      var i = this.index(handle);\n      if (i < this.data.length) {\n        return this.data[i];\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      var _iterator = _createForOfIteratorHelper(this.data),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var elt = _step.value;\n          if (elt != null) f(elt);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      return this.data.filter(function (elt) {\n        return elt != null;\n      });\n    }\n  }, {\n    key: \"index\",\n    value: function index(handle) {\n      /// Extracts the index part of a handle (the lower 32 bits).\n      /// This is done by first injecting the handle into an Float64Array\n      /// which is itself injected into an Uint32Array (at construction time).\n      /// The 0-th value of the Uint32Array will become the `number` integer\n      /// representation of the lower 32 bits.\n      /// Also `this.uconv[1]` then contains the generation number as a `number`,\n      /// which we don’t really need.\n      this.fconv[0] = handle;\n      return this.uconv[0];\n    }\n  }]);\n  return Coarena;\n}();\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/coarena.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/control/character_controller.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/control/character_controller.js ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterCollision: () => (/* binding */ CharacterCollision),\n/* harmony export */   KinematicCharacterController: () => (/* binding */ KinematicCharacterController)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nvar CharacterCollision = /*#__PURE__*/_createClass(function CharacterCollision() {\n  _classCallCheck(this, CharacterCollision);\n});\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nvar KinematicCharacterController = /*#__PURE__*/function () {\n  function KinematicCharacterController(offset, params, bodies, colliders, queries) {\n    _classCallCheck(this, KinematicCharacterController);\n    this.params = params;\n    this.bodies = bodies;\n    this.colliders = colliders;\n    this.queries = queries;\n    this.raw = new _raw__WEBPACK_IMPORTED_MODULE_0__.RawKinematicCharacterController(offset);\n    this.rawCharacterCollision = new _raw__WEBPACK_IMPORTED_MODULE_0__.RawCharacterCollision();\n    this._applyImpulsesToDynamicBodies = false;\n    this._characterMass = null;\n  }\n  /** @internal */\n  _createClass(KinematicCharacterController, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n        this.rawCharacterCollision.free();\n      }\n      this.raw = undefined;\n      this.rawCharacterCollision = undefined;\n    }\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floor’s angle.\n     */\n  }, {\n    key: \"up\",\n    value: function up() {\n      return this.raw.up();\n    }\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floor’s angle.\n     */\n  }, {\n    key: \"setUp\",\n    value: function setUp(vector) {\n      var rawVect = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(vector);\n      return this.raw.setUp(rawVect);\n      rawVect.free();\n    }\n  }, {\n    key: \"applyImpulsesToDynamicBodies\",\n    value: function applyImpulsesToDynamicBodies() {\n      return this._applyImpulsesToDynamicBodies;\n    }\n  }, {\n    key: \"setApplyImpulsesToDynamicBodies\",\n    value: function setApplyImpulsesToDynamicBodies(enabled) {\n      this._applyImpulsesToDynamicBodies = enabled;\n    }\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n  }, {\n    key: \"characterMass\",\n    value: function characterMass() {\n      return this._characterMass;\n    }\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isn’t attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n  }, {\n    key: \"setCharacterMass\",\n    value: function setCharacterMass(mass) {\n      this._characterMass = mass;\n    }\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n  }, {\n    key: \"offset\",\n    value: function offset() {\n      return this.raw.offset();\n    }\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n  }, {\n    key: \"setOffset\",\n    value: function setOffset(value) {\n      this.raw.setOffset(value);\n    }\n    /**\n     * Is sliding against obstacles enabled?\n     */\n  }, {\n    key: \"slideEnabled\",\n    value: function slideEnabled() {\n      return this.raw.slideEnabled();\n    }\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n  }, {\n    key: \"setSlideEnabled\",\n    value: function setSlideEnabled(enabled) {\n      this.raw.setSlideEnabled(enabled);\n    }\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n  }, {\n    key: \"autostepMaxHeight\",\n    value: function autostepMaxHeight() {\n      return this.raw.autostepMaxHeight();\n    }\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n  }, {\n    key: \"autostepMinWidth\",\n    value: function autostepMinWidth() {\n      return this.raw.autostepMinWidth();\n    }\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n  }, {\n    key: \"autostepIncludesDynamicBodies\",\n    value: function autostepIncludesDynamicBodies() {\n      return this.raw.autostepIncludesDynamicBodies();\n    }\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n  }, {\n    key: \"autostepEnabled\",\n    value: function autostepEnabled() {\n      return this.raw.autostepEnabled();\n    }\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n  }, {\n    key: \"enableAutostep\",\n    value: function enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n      this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n     * Disable automatically stepping over small objects.\n     */\n  }, {\n    key: \"disableAutostep\",\n    value: function disableAutostep() {\n      return this.raw.disableAutostep();\n    }\n    /**\n     * The maximum angle (radians) between the floor’s normal and the `up` vector that the\n     * character is able to climb.\n     */\n  }, {\n    key: \"maxSlopeClimbAngle\",\n    value: function maxSlopeClimbAngle() {\n      return this.raw.maxSlopeClimbAngle();\n    }\n    /**\n     * Sets the maximum angle (radians) between the floor’s normal and the `up` vector that the\n     * character is able to climb.\n     */\n  }, {\n    key: \"setMaxSlopeClimbAngle\",\n    value: function setMaxSlopeClimbAngle(angle) {\n      this.raw.setMaxSlopeClimbAngle(angle);\n    }\n    /**\n     * The minimum angle (radians) between the floor’s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n  }, {\n    key: \"minSlopeSlideAngle\",\n    value: function minSlopeSlideAngle() {\n      return this.raw.minSlopeSlideAngle();\n    }\n    /**\n     * Sets the minimum angle (radians) between the floor’s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n  }, {\n    key: \"setMinSlopeSlideAngle\",\n    value: function setMinSlopeSlideAngle(angle) {\n      this.raw.setMinSlopeSlideAngle(angle);\n    }\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n  }, {\n    key: \"snapToGroundDistance\",\n    value: function snapToGroundDistance() {\n      return this.raw.snapToGroundDistance();\n    }\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n  }, {\n    key: \"enableSnapToGround\",\n    value: function enableSnapToGround(distance) {\n      this.raw.enableSnapToGround(distance);\n    }\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n  }, {\n    key: \"disableSnapToGround\",\n    value: function disableSnapToGround() {\n      this.raw.disableSnapToGround();\n    }\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n  }, {\n    key: \"snapToGroundEnabled\",\n    value: function snapToGroundEnabled() {\n      return this.raw.snapToGroundEnabled();\n    }\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslationDelta - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n  }, {\n    key: \"computeColliderMovement\",\n    value: function computeColliderMovement(collider, desiredTranslationDelta, filterFlags, filterGroups, filterPredicate) {\n      var rawTranslationDelta = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(desiredTranslationDelta);\n      this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, collider.handle, rawTranslationDelta, this._applyImpulsesToDynamicBodies, this._characterMass, filterFlags, filterGroups, this.colliders.castClosure(filterPredicate));\n      rawTranslationDelta.free();\n    }\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n  }, {\n    key: \"computedMovement\",\n    value: function computedMovement() {\n      return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.computedMovement());\n    }\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n  }, {\n    key: \"computedGrounded\",\n    value: function computedGrounded() {\n      return this.raw.computedGrounded();\n    }\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n  }, {\n    key: \"numComputedCollisions\",\n    value: function numComputedCollisions() {\n      return this.raw.numComputedCollisions();\n    }\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n  }, {\n    key: \"computedCollision\",\n    value: function computedCollision(i, out) {\n      if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n        return null;\n      } else {\n        var c = this.rawCharacterCollision;\n        out = out !== null && out !== void 0 ? out : new CharacterCollision();\n        out.translationDeltaApplied = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.translationDeltaApplied());\n        out.translationDeltaRemaining = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.translationDeltaRemaining());\n        out.toi = c.toi();\n        out.witness1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldWitness1());\n        out.witness2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldWitness2());\n        out.normal1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldNormal1());\n        out.normal2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldNormal2());\n        out.collider = this.colliders.get(c.handle());\n        return out;\n      }\n    }\n  }]);\n  return KinematicCharacterController;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/control/character_controller.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/control/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/control/index.js ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterCollision: () => (/* reexport safe */ _character_controller__WEBPACK_IMPORTED_MODULE_0__.CharacterCollision),\n/* harmony export */   KinematicCharacterController: () => (/* reexport safe */ _character_controller__WEBPACK_IMPORTED_MODULE_0__.KinematicCharacterController)\n/* harmony export */ });\n/* harmony import */ var _character_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character_controller */ \"./node_modules/@dimforge/rapier2d/control/character_controller.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_character_controller__WEBPACK_IMPORTED_MODULE_0__]);\n_character_controller__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/control/index.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CCDSolver: () => (/* binding */ CCDSolver)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nvar CCDSolver = /*#__PURE__*/function () {\n  function CCDSolver(raw) {\n    _classCallCheck(this, CCDSolver);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawCCDSolver();\n  }\n  /**\n   * Release the WASM memory occupied by this narrow-phase.\n   */\n  _createClass(CCDSolver, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n    }\n  }]);\n  return CCDSolver;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoefficientCombineRule: () => (/* binding */ CoefficientCombineRule)\n/* harmony export */ });\n/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nvar CoefficientCombineRule;\n(function (CoefficientCombineRule) {\n  CoefficientCombineRule[CoefficientCombineRule[\"Average\"] = 0] = \"Average\";\n  CoefficientCombineRule[CoefficientCombineRule[\"Min\"] = 1] = \"Min\";\n  CoefficientCombineRule[CoefficientCombineRule[\"Multiply\"] = 2] = \"Multiply\";\n  CoefficientCombineRule[CoefficientCombineRule[\"Max\"] = 3] = \"Max\";\n})(CoefficientCombineRule || (CoefficientCombineRule = {}));\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedImpulseJoint: () => (/* binding */ FixedImpulseJoint),\n/* harmony export */   ImpulseJoint: () => (/* binding */ ImpulseJoint),\n/* harmony export */   JointAxesMask: () => (/* binding */ JointAxesMask),\n/* harmony export */   JointData: () => (/* binding */ JointData),\n/* harmony export */   JointType: () => (/* binding */ JointType),\n/* harmony export */   MotorModel: () => (/* binding */ MotorModel),\n/* harmony export */   PrismaticImpulseJoint: () => (/* binding */ PrismaticImpulseJoint),\n/* harmony export */   RevoluteImpulseJoint: () => (/* binding */ RevoluteImpulseJoint),\n/* harmony export */   RopeImpulseJoint: () => (/* binding */ RopeImpulseJoint),\n/* harmony export */   SpringImpulseJoint: () => (/* binding */ SpringImpulseJoint),\n/* harmony export */   UnitImpulseJoint: () => (/* binding */ UnitImpulseJoint)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__]);\n([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n * - `Generic`: (3D only) A joint with customizable degrees of freedom, allowing any of the 6 axes to be locked.\n */\nvar JointType;\n(function (JointType) {\n  JointType[JointType[\"Revolute\"] = 0] = \"Revolute\";\n  JointType[JointType[\"Fixed\"] = 1] = \"Fixed\";\n  JointType[JointType[\"Prismatic\"] = 2] = \"Prismatic\";\n  JointType[JointType[\"Rope\"] = 3] = \"Rope\";\n  JointType[JointType[\"Spring\"] = 4] = \"Spring\";\n})(JointType || (JointType = {}));\nvar MotorModel;\n(function (MotorModel) {\n  MotorModel[MotorModel[\"AccelerationBased\"] = 0] = \"AccelerationBased\";\n  MotorModel[MotorModel[\"ForceBased\"] = 1] = \"ForceBased\";\n})(MotorModel || (MotorModel = {}));\n/**\n * An enum representing the possible joint axes of a generic joint.\n * They can be ORed together, like:\n * JointAxesMask.X || JointAxesMask.Y\n * to get a joint that is only free in the X and Y translational (positional) axes.\n *\n * Possible free axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis\n * - `AngY`: Y angular rotations axis\n * - `AngZ`: Z angular rotation axis\n */\nvar JointAxesMask;\n(function (JointAxesMask) {\n  JointAxesMask[JointAxesMask[\"X\"] = 1] = \"X\";\n  JointAxesMask[JointAxesMask[\"Y\"] = 2] = \"Y\";\n  JointAxesMask[JointAxesMask[\"Z\"] = 4] = \"Z\";\n  JointAxesMask[JointAxesMask[\"AngX\"] = 8] = \"AngX\";\n  JointAxesMask[JointAxesMask[\"AngY\"] = 16] = \"AngY\";\n  JointAxesMask[JointAxesMask[\"AngZ\"] = 32] = \"AngZ\";\n})(JointAxesMask || (JointAxesMask = {}));\nvar ImpulseJoint = /*#__PURE__*/function () {\n  function ImpulseJoint(rawSet, bodySet, handle) {\n    _classCallCheck(this, ImpulseJoint);\n    this.rawSet = rawSet;\n    this.bodySet = bodySet;\n    this.handle = handle;\n  }\n  _createClass(ImpulseJoint, [{\n    key: \"finalizeDeserialization\",\n    value: /** @internal */\n    function finalizeDeserialization(bodySet) {\n      this.bodySet = bodySet;\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      return this.rawSet.contains(this.handle);\n    }\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n  }, {\n    key: \"body1\",\n    value: function body1() {\n      return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n  }, {\n    key: \"body2\",\n    value: function body2() {\n      return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n    /**\n     * The type of this joint given as a string.\n     */\n  }, {\n    key: \"type\",\n    value: function type() {\n      return this.rawSet.jointType(this.handle);\n    }\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n  }, {\n    key: \"anchor1\",\n    value: function anchor1() {\n      return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n  }, {\n    key: \"anchor2\",\n    value: function anchor2() {\n      return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n  }, {\n    key: \"setAnchor1\",\n    value: function setAnchor1(newPos) {\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(newPos);\n      this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n      rawPoint.free();\n    }\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n  }, {\n    key: \"setAnchor2\",\n    value: function setAnchor2(newPos) {\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(newPos);\n      this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n      rawPoint.free();\n    }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n  }, {\n    key: \"setContactsEnabled\",\n    value: function setContactsEnabled(enabled) {\n      this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n  }, {\n    key: \"contactsEnabled\",\n    value: function contactsEnabled() {\n      return this.rawSet.jointContactsEnabled(this.handle);\n    }\n  }], [{\n    key: \"newTyped\",\n    value: function newTyped(rawSet, bodySet, handle) {\n      switch (rawSet.jointType(handle)) {\n        case _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointType.Revolute:\n          return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n        case _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointType.Prismatic:\n          return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n        case _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointType.Fixed:\n          return new FixedImpulseJoint(rawSet, bodySet, handle);\n        case _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointType.Spring:\n          return new SpringImpulseJoint(rawSet, bodySet, handle);\n        case _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointType.Rope:\n          return new RopeImpulseJoint(rawSet, bodySet, handle);\n        default:\n          return new ImpulseJoint(rawSet, bodySet, handle);\n      }\n    }\n  }]);\n  return ImpulseJoint;\n}();\nvar UnitImpulseJoint = /*#__PURE__*/function (_ImpulseJoint) {\n  _inherits(UnitImpulseJoint, _ImpulseJoint);\n  function UnitImpulseJoint() {\n    _classCallCheck(this, UnitImpulseJoint);\n    return _callSuper(this, UnitImpulseJoint, arguments);\n  }\n  _createClass(UnitImpulseJoint, [{\n    key: \"limitsEnabled\",\n    value:\n    /**\n     * Are the limits enabled for this joint?\n     */\n    function limitsEnabled() {\n      return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n    /**\n     * The min limit of this joint.\n     */\n  }, {\n    key: \"limitsMin\",\n    value: function limitsMin() {\n      return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n    /**\n     * The max limit of this joint.\n     */\n  }, {\n    key: \"limitsMax\",\n    value: function limitsMax() {\n      return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joint’s free coordinate.\n     * @param max - The maximum bound of this joint’s free coordinate.\n     */\n  }, {\n    key: \"setLimits\",\n    value: function setLimits(min, max) {\n      this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n  }, {\n    key: \"configureMotorModel\",\n    value: function configureMotorModel(model) {\n      this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    }\n  }, {\n    key: \"configureMotorVelocity\",\n    value: function configureMotorVelocity(targetVel, factor) {\n      this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    }\n  }, {\n    key: \"configureMotorPosition\",\n    value: function configureMotorPosition(targetPos, stiffness, damping) {\n      this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    }\n  }, {\n    key: \"configureMotor\",\n    value: function configureMotor(targetPos, targetVel, stiffness, damping) {\n      this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    }\n  }]);\n  return UnitImpulseJoint;\n}(ImpulseJoint);\nvar FixedImpulseJoint = /*#__PURE__*/function (_ImpulseJoint2) {\n  _inherits(FixedImpulseJoint, _ImpulseJoint2);\n  function FixedImpulseJoint() {\n    _classCallCheck(this, FixedImpulseJoint);\n    return _callSuper(this, FixedImpulseJoint, arguments);\n  }\n  return _createClass(FixedImpulseJoint);\n}(ImpulseJoint);\nvar RopeImpulseJoint = /*#__PURE__*/function (_ImpulseJoint3) {\n  _inherits(RopeImpulseJoint, _ImpulseJoint3);\n  function RopeImpulseJoint() {\n    _classCallCheck(this, RopeImpulseJoint);\n    return _callSuper(this, RopeImpulseJoint, arguments);\n  }\n  return _createClass(RopeImpulseJoint);\n}(ImpulseJoint);\nvar SpringImpulseJoint = /*#__PURE__*/function (_ImpulseJoint4) {\n  _inherits(SpringImpulseJoint, _ImpulseJoint4);\n  function SpringImpulseJoint() {\n    _classCallCheck(this, SpringImpulseJoint);\n    return _callSuper(this, SpringImpulseJoint, arguments);\n  }\n  return _createClass(SpringImpulseJoint);\n}(ImpulseJoint);\nvar PrismaticImpulseJoint = /*#__PURE__*/function (_UnitImpulseJoint) {\n  _inherits(PrismaticImpulseJoint, _UnitImpulseJoint);\n  function PrismaticImpulseJoint() {\n    _classCallCheck(this, PrismaticImpulseJoint);\n    return _callSuper(this, PrismaticImpulseJoint, arguments);\n  }\n  _createClass(PrismaticImpulseJoint, [{\n    key: \"rawAxis\",\n    value: function rawAxis() {\n      return _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointAxis.X;\n    }\n  }]);\n  return PrismaticImpulseJoint;\n}(UnitImpulseJoint);\nvar RevoluteImpulseJoint = /*#__PURE__*/function (_UnitImpulseJoint2) {\n  _inherits(RevoluteImpulseJoint, _UnitImpulseJoint2);\n  function RevoluteImpulseJoint() {\n    _classCallCheck(this, RevoluteImpulseJoint);\n    return _callSuper(this, RevoluteImpulseJoint, arguments);\n  }\n  _createClass(RevoluteImpulseJoint, [{\n    key: \"rawAxis\",\n    value: function rawAxis() {\n      return _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointAxis.AngX;\n    }\n  }]);\n  return RevoluteImpulseJoint;\n}(UnitImpulseJoint);\nvar JointData = /*#__PURE__*/function () {\n  function JointData() {\n    _classCallCheck(this, JointData);\n  }\n  /**\n   * Creates a new joint descriptor that builds a Fixed joint.\n   *\n   * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n   * anchor and local frames coincide in world-space.\n   *\n   * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n   *                  local-space of the rigid-body.\n   * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n   * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n   *                  local-space of the rigid-body.\n   * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n   */\n  _createClass(JointData, [{\n    key: \"intoRaw\",\n    value:\n    // #endif\n    function intoRaw() {\n      var rawA1 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.anchor1);\n      var rawA2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.anchor2);\n      var rawAx;\n      var result;\n      var limitsEnabled = false;\n      var limitsMin = 0.0;\n      var limitsMax = 0.0;\n      switch (this.jointType) {\n        case JointType.Fixed:\n          var rawFra1 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(this.frame1);\n          var rawFra2 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(this.frame2);\n          result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n          rawFra1.free();\n          rawFra2.free();\n          break;\n        case JointType.Spring:\n          result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.spring(this.length, this.stiffness, this.damping, rawA1, rawA2);\n          break;\n        case JointType.Rope:\n          result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.rope(this.length, rawA1, rawA2);\n          break;\n        case JointType.Prismatic:\n          rawAx = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.axis);\n          if (!!this.limitsEnabled) {\n            limitsEnabled = true;\n            limitsMin = this.limits[0];\n            limitsMax = this.limits[1];\n          }\n          // #if DIM2\n          result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.prismatic(rawA1, rawA2, rawAx, limitsEnabled, limitsMin, limitsMax);\n          // #endif\n          rawAx.free();\n          break;\n        // #if DIM2\n        case JointType.Revolute:\n          result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.revolute(rawA1, rawA2);\n          break;\n        // #endif\n      }\n      rawA1.free();\n      rawA2.free();\n      return result;\n    }\n  }], [{\n    key: \"fixed\",\n    value: function fixed(anchor1, frame1, anchor2, frame2) {\n      var res = new JointData();\n      res.anchor1 = anchor1;\n      res.anchor2 = anchor2;\n      res.frame1 = frame1;\n      res.frame2 = frame2;\n      res.jointType = JointType.Fixed;\n      return res;\n    }\n  }, {\n    key: \"spring\",\n    value: function spring(rest_length, stiffness, damping, anchor1, anchor2) {\n      var res = new JointData();\n      res.anchor1 = anchor1;\n      res.anchor2 = anchor2;\n      res.length = rest_length;\n      res.stiffness = stiffness;\n      res.damping = damping;\n      res.jointType = JointType.Spring;\n      return res;\n    }\n  }, {\n    key: \"rope\",\n    value: function rope(length, anchor1, anchor2) {\n      var res = new JointData();\n      res.anchor1 = anchor1;\n      res.anchor2 = anchor2;\n      res.length = length;\n      res.jointType = JointType.Rope;\n      return res;\n    }\n    // #if DIM2\n    /**\n     * Create a new joint descriptor that builds revolute joints.\n     *\n     * A revolute joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n  }, {\n    key: \"revolute\",\n    value: function revolute(anchor1, anchor2) {\n      var res = new JointData();\n      res.anchor1 = anchor1;\n      res.anchor2 = anchor2;\n      res.jointType = JointType.Revolute;\n      return res;\n    }\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n  }, {\n    key: \"prismatic\",\n    value: function prismatic(anchor1, anchor2, axis) {\n      var res = new JointData();\n      res.anchor1 = anchor1;\n      res.anchor2 = anchor2;\n      res.axis = axis;\n      res.jointType = JointType.Prismatic;\n      return res;\n    }\n  }]);\n  return JointData;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImpulseJointSet: () => (/* binding */ ImpulseJointSet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"./node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _impulse_joint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impulse_joint */ \"./node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nvar ImpulseJointSet = /*#__PURE__*/function () {\n  function ImpulseJointSet(raw) {\n    var _this = this;\n    _classCallCheck(this, ImpulseJointSet);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawImpulseJointSet();\n    this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n    // Initialize the map with the existing elements, if any.\n    if (raw) {\n      raw.forEachJointHandle(function (handle) {\n        _this.map.set(handle, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint.newTyped(raw, null, handle));\n      });\n    }\n  }\n  /**\n   * Release the WASM memory occupied by this joint set.\n   */\n  _createClass(ImpulseJointSet, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n      if (!!this.map) {\n        this.map.clear();\n      }\n      this.map = undefined;\n    }\n    /** @internal */\n  }, {\n    key: \"finalizeDeserialization\",\n    value: function finalizeDeserialization(bodies) {\n      this.map.forEach(function (joint) {\n        return joint.finalizeDeserialization(bodies);\n      });\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n  }, {\n    key: \"createJoint\",\n    value: function createJoint(bodies, desc, parent1, parent2, wakeUp) {\n      var rawParams = desc.intoRaw();\n      var handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n      rawParams.free();\n      var joint = _impulse_joint__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint.newTyped(this.raw, bodies, handle);\n      this.map.set(handle, joint);\n      return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(handle, wakeUp) {\n      this.raw.remove(handle, wakeUp);\n      this.unmap(handle);\n    }\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n  }, {\n    key: \"forEachJointHandleAttachedToRigidBody\",\n    value: function forEachJointHandleAttachedToRigidBody(handle, f) {\n      this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n  }, {\n    key: \"unmap\",\n    value: function unmap(handle) {\n      this.map[\"delete\"](handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n  }, {\n    key: \"len\",\n    value: function len() {\n      return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n  }, {\n    key: \"contains\",\n    value: function contains(handle) {\n      return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n  }, {\n    key: \"get\",\n    value: function get(handle) {\n      return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      this.map.forEach(f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      return this.map.getAll();\n    }\n  }]);\n  return ImpulseJointSet;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/index.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CCDSolver: () => (/* reexport safe */ _ccd_solver__WEBPACK_IMPORTED_MODULE_8__.CCDSolver),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _coefficient_combine_rule__WEBPACK_IMPORTED_MODULE_7__.CoefficientCombineRule),\n/* harmony export */   FixedImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.FixedImpulseJoint),\n/* harmony export */   FixedMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.FixedMultibodyJoint),\n/* harmony export */   ImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.ImpulseJoint),\n/* harmony export */   ImpulseJointSet: () => (/* reexport safe */ _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__.ImpulseJointSet),\n/* harmony export */   IntegrationParameters: () => (/* reexport safe */ _integration_parameters__WEBPACK_IMPORTED_MODULE_2__.IntegrationParameters),\n/* harmony export */   IslandManager: () => (/* reexport safe */ _island_manager__WEBPACK_IMPORTED_MODULE_9__.IslandManager),\n/* harmony export */   JointAxesMask: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.JointAxesMask),\n/* harmony export */   JointData: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.JointData),\n/* harmony export */   JointType: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.JointType),\n/* harmony export */   MotorModel: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.MotorModel),\n/* harmony export */   MultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.MultibodyJoint),\n/* harmony export */   MultibodyJointSet: () => (/* reexport safe */ _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__.MultibodyJointSet),\n/* harmony export */   PrismaticImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.PrismaticImpulseJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.PrismaticMultibodyJoint),\n/* harmony export */   RevoluteImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.RevoluteImpulseJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.RevoluteMultibodyJoint),\n/* harmony export */   RigidBody: () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc),\n/* harmony export */   RigidBodySet: () => (/* reexport safe */ _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__.RigidBodySet),\n/* harmony export */   RigidBodyType: () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBodyType),\n/* harmony export */   RopeImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.RopeImpulseJoint),\n/* harmony export */   SpringImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.SpringImpulseJoint),\n/* harmony export */   UnitImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.UnitImpulseJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.UnitMultibodyJoint)\n/* harmony export */ });\n/* harmony import */ var _rigid_body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rigid_body */ \"./node_modules/@dimforge/rapier2d/dynamics/rigid_body.js\");\n/* harmony import */ var _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rigid_body_set */ \"./node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js\");\n/* harmony import */ var _integration_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./integration_parameters */ \"./node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js\");\n/* harmony import */ var _impulse_joint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impulse_joint */ \"./node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js\");\n/* harmony import */ var _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impulse_joint_set */ \"./node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js\");\n/* harmony import */ var _multibody_joint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./multibody_joint */ \"./node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js\");\n/* harmony import */ var _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./multibody_joint_set */ \"./node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js\");\n/* harmony import */ var _coefficient_combine_rule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coefficient_combine_rule */ \"./node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js\");\n/* harmony import */ var _ccd_solver__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ccd_solver */ \"./node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js\");\n/* harmony import */ var _island_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./island_manager */ \"./node_modules/@dimforge/rapier2d/dynamics/island_manager.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_rigid_body__WEBPACK_IMPORTED_MODULE_0__, _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__, _integration_parameters__WEBPACK_IMPORTED_MODULE_2__, _impulse_joint__WEBPACK_IMPORTED_MODULE_3__, _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__, _multibody_joint__WEBPACK_IMPORTED_MODULE_5__, _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__, _ccd_solver__WEBPACK_IMPORTED_MODULE_8__, _island_manager__WEBPACK_IMPORTED_MODULE_9__]);\n([_rigid_body__WEBPACK_IMPORTED_MODULE_0__, _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__, _integration_parameters__WEBPACK_IMPORTED_MODULE_2__, _impulse_joint__WEBPACK_IMPORTED_MODULE_3__, _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__, _multibody_joint__WEBPACK_IMPORTED_MODULE_5__, _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__, _ccd_solver__WEBPACK_IMPORTED_MODULE_8__, _island_manager__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/dynamics/index.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegrationParameters: () => (/* binding */ IntegrationParameters)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar IntegrationParameters = /*#__PURE__*/function () {\n  function IntegrationParameters(raw) {\n    _classCallCheck(this, IntegrationParameters);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawIntegrationParameters();\n  }\n  /**\n   * Free the WASM memory used by these integration parameters.\n   */\n  _createClass(IntegrationParameters, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n    }\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n  }, {\n    key: \"dt\",\n    get: function get() {\n      return this.raw.dt;\n    }\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */,\n    set: function set(value) {\n      this.raw.dt = value;\n    }\n  }, {\n    key: \"erp\",\n    get: function get() {\n      return this.raw.erp;\n    }\n    /**\n     * Amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     */,\n    set: function set(value) {\n      this.raw.erp = value;\n    }\n  }, {\n    key: \"allowedLinearError\",\n    get: function get() {\n      return this.raw.allowedLinearError;\n    }\n    /**\n     * The maximal distance separating two objects that will generate predictive contacts (default: `0.002`).\n     */,\n    set: function set(value) {\n      this.raw.allowedLinearError = value;\n    }\n  }, {\n    key: \"predictionDistance\",\n    get: function get() {\n      return this.raw.predictionDistance;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */,\n    set: function set(value) {\n      this.raw.predictionDistance = value;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n  }, {\n    key: \"numSolverIterations\",\n    get: function get() {\n      return this.raw.numSolverIterations;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */,\n    set: function set(value) {\n      this.raw.numSolverIterations = value;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n  }, {\n    key: \"numAdditionalFrictionIterations\",\n    get: function get() {\n      return this.raw.numAdditionalFrictionIterations;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */,\n    set: function set(value) {\n      this.raw.numAdditionalFrictionIterations = value;\n    }\n    /**\n     * Sets the number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n  }, {\n    key: \"numInternalPgsIterations\",\n    get: function get() {\n      return this.raw.numInternalPgsIterations;\n    }\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */,\n    set: function set(value) {\n      this.raw.numInternalPgsIterations = value;\n    }\n  }, {\n    key: \"minIslandSize\",\n    get: function get() {\n      return this.raw.minIslandSize;\n    }\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */,\n    set: function set(value) {\n      this.raw.minIslandSize = value;\n    }\n  }, {\n    key: \"maxCcdSubsteps\",\n    get: function get() {\n      return this.raw.maxCcdSubsteps;\n    },\n    set: function set(value) {\n      this.raw.maxCcdSubsteps = value;\n    }\n  }, {\n    key: \"switchToStandardPgsSolver\",\n    value: function switchToStandardPgsSolver() {\n      this.raw.switchToStandardPgsSolver();\n    }\n  }, {\n    key: \"switchToSmallStepsPgsSolver\",\n    value: function switchToSmallStepsPgsSolver() {\n      this.raw.switchToSmallStepsPgsSolver();\n    }\n  }]);\n  return IntegrationParameters;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/island_manager.js":
/*!********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/island_manager.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IslandManager: () => (/* binding */ IslandManager)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nvar IslandManager = /*#__PURE__*/function () {\n  function IslandManager(raw) {\n    _classCallCheck(this, IslandManager);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawIslandManager();\n  }\n  /**\n   * Release the WASM memory occupied by this narrow-phase.\n   */\n  _createClass(IslandManager, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n    }\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n  }, {\n    key: \"forEachActiveRigidBodyHandle\",\n    value: function forEachActiveRigidBodyHandle(f) {\n      this.raw.forEachActiveRigidBodyHandle(f);\n    }\n  }]);\n  return IslandManager;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/dynamics/island_manager.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedMultibodyJoint: () => (/* binding */ FixedMultibodyJoint),\n/* harmony export */   MultibodyJoint: () => (/* binding */ MultibodyJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* binding */ PrismaticMultibodyJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* binding */ RevoluteMultibodyJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* binding */ UnitMultibodyJoint)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar MultibodyJoint = /*#__PURE__*/function () {\n  function MultibodyJoint(rawSet, handle) {\n    _classCallCheck(this, MultibodyJoint);\n    this.rawSet = rawSet;\n    this.handle = handle;\n  }\n  _createClass(MultibodyJoint, [{\n    key: \"isValid\",\n    value:\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    function isValid() {\n      return this.rawSet.contains(this.handle);\n    }\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    //\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n  }, {\n    key: \"setContactsEnabled\",\n    value: function setContactsEnabled(enabled) {\n      this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n  }, {\n    key: \"contactsEnabled\",\n    value: function contactsEnabled() {\n      return this.rawSet.jointContactsEnabled(this.handle);\n    }\n  }], [{\n    key: \"newTyped\",\n    value: function newTyped(rawSet, handle) {\n      switch (rawSet.jointType(handle)) {\n        case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Revolute:\n          return new RevoluteMultibodyJoint(rawSet, handle);\n        case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Prismatic:\n          return new PrismaticMultibodyJoint(rawSet, handle);\n        case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Fixed:\n          return new FixedMultibodyJoint(rawSet, handle);\n        default:\n          return new MultibodyJoint(rawSet, handle);\n      }\n    }\n  }]);\n  return MultibodyJoint;\n}();\nvar UnitMultibodyJoint = /*#__PURE__*/function (_MultibodyJoint) {\n  _inherits(UnitMultibodyJoint, _MultibodyJoint);\n  function UnitMultibodyJoint() {\n    _classCallCheck(this, UnitMultibodyJoint);\n    return _callSuper(this, UnitMultibodyJoint, arguments);\n  }\n  return _createClass(UnitMultibodyJoint);\n}(MultibodyJoint);\nvar FixedMultibodyJoint = /*#__PURE__*/function (_MultibodyJoint2) {\n  _inherits(FixedMultibodyJoint, _MultibodyJoint2);\n  function FixedMultibodyJoint() {\n    _classCallCheck(this, FixedMultibodyJoint);\n    return _callSuper(this, FixedMultibodyJoint, arguments);\n  }\n  return _createClass(FixedMultibodyJoint);\n}(MultibodyJoint);\nvar PrismaticMultibodyJoint = /*#__PURE__*/function (_UnitMultibodyJoint) {\n  _inherits(PrismaticMultibodyJoint, _UnitMultibodyJoint);\n  function PrismaticMultibodyJoint() {\n    _classCallCheck(this, PrismaticMultibodyJoint);\n    return _callSuper(this, PrismaticMultibodyJoint, arguments);\n  }\n  _createClass(PrismaticMultibodyJoint, [{\n    key: \"rawAxis\",\n    value: function rawAxis() {\n      return _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis.X;\n    }\n  }]);\n  return PrismaticMultibodyJoint;\n}(UnitMultibodyJoint);\nvar RevoluteMultibodyJoint = /*#__PURE__*/function (_UnitMultibodyJoint2) {\n  _inherits(RevoluteMultibodyJoint, _UnitMultibodyJoint2);\n  function RevoluteMultibodyJoint() {\n    _classCallCheck(this, RevoluteMultibodyJoint);\n    return _callSuper(this, RevoluteMultibodyJoint, arguments);\n  }\n  _createClass(RevoluteMultibodyJoint, [{\n    key: \"rawAxis\",\n    value: function rawAxis() {\n      return _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis.AngX;\n    }\n  }]);\n  return RevoluteMultibodyJoint;\n}(UnitMultibodyJoint);\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultibodyJointSet: () => (/* binding */ MultibodyJointSet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"./node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _multibody_joint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./multibody_joint */ \"./node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nvar MultibodyJointSet = /*#__PURE__*/function () {\n  function MultibodyJointSet(raw) {\n    var _this = this;\n    _classCallCheck(this, MultibodyJointSet);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawMultibodyJointSet();\n    this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n    // Initialize the map with the existing elements, if any.\n    if (raw) {\n      raw.forEachJointHandle(function (handle) {\n        _this.map.set(handle, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint.newTyped(_this.raw, handle));\n      });\n    }\n  }\n  /**\n   * Release the WASM memory occupied by this joint set.\n   */\n  _createClass(MultibodyJointSet, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n      if (!!this.map) {\n        this.map.clear();\n      }\n      this.map = undefined;\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n  }, {\n    key: \"createJoint\",\n    value: function createJoint(desc, parent1, parent2, wakeUp) {\n      var rawParams = desc.intoRaw();\n      var handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n      rawParams.free();\n      var joint = _multibody_joint__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint.newTyped(this.raw, handle);\n      this.map.set(handle, joint);\n      return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(handle, wake_up) {\n      this.raw.remove(handle, wake_up);\n      this.map[\"delete\"](handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n  }, {\n    key: \"unmap\",\n    value: function unmap(handle) {\n      this.map[\"delete\"](handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n  }, {\n    key: \"len\",\n    value: function len() {\n      return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n  }, {\n    key: \"contains\",\n    value: function contains(handle) {\n      return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n  }, {\n    key: \"get\",\n    value: function get(handle) {\n      return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      this.map.forEach(f);\n    }\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n  }, {\n    key: \"forEachJointHandleAttachedToRigidBody\",\n    value: function forEachJointHandleAttachedToRigidBody(handle, f) {\n      this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      return this.map.getAll();\n    }\n  }]);\n  return MultibodyJointSet;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/rigid_body.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/rigid_body.js ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RigidBody: () => (/* binding */ RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* binding */ RigidBodyDesc),\n/* harmony export */   RigidBodyType: () => (/* binding */ RigidBodyType)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nvar RigidBodyType;\n(function (RigidBodyType) {\n  /**\n   * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n   */\n  RigidBodyType[RigidBodyType[\"Dynamic\"] = 0] = \"Dynamic\";\n  /**\n   * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n   */\n  RigidBodyType[RigidBodyType[\"Fixed\"] = 1] = \"Fixed\";\n  /**\n   * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n   * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n   *\n   * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n   * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n   * modified by the user and is independent from any contact or joint it is involved in.\n   */\n  RigidBodyType[RigidBodyType[\"KinematicPositionBased\"] = 2] = \"KinematicPositionBased\";\n  /**\n   * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n   * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n   *\n   * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n   * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n   * modified by the user and is independent from any contact or joint it is involved in.\n   */\n  RigidBodyType[RigidBodyType[\"KinematicVelocityBased\"] = 3] = \"KinematicVelocityBased\";\n})(RigidBodyType || (RigidBodyType = {}));\n/**\n * A rigid-body.\n */\nvar RigidBody = /*#__PURE__*/function () {\n  function RigidBody(rawSet, colliderSet, handle) {\n    _classCallCheck(this, RigidBody);\n    this.rawSet = rawSet;\n    this.colliderSet = colliderSet;\n    this.handle = handle;\n  }\n  /** @internal */\n  _createClass(RigidBody, [{\n    key: \"finalizeDeserialization\",\n    value: function finalizeDeserialization(colliderSet) {\n      this.colliderSet = colliderSet;\n    }\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      return this.rawSet.contains(this.handle);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n  }, {\n    key: \"lockTranslations\",\n    value: function lockTranslations(locked, wakeUp) {\n      return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n  }, {\n    key: \"lockRotations\",\n    value: function lockRotations(locked, wakeUp) {\n      return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n  }, {\n    key: \"setEnabledTranslations\",\n    value: function setEnabledTranslations(enableX, enableY, wakeUp) {\n      return this.rawSet.rbSetEnabledTranslations(this.handle, enableX, enableY, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n  }, {\n    key: \"restrictTranslations\",\n    value: function restrictTranslations(enableX, enableY, wakeUp) {\n      this.setEnabledTranslations(enableX, enableX, wakeUp);\n    }\n    // #endif\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n  }, {\n    key: \"dominanceGroup\",\n    value: function dominanceGroup() {\n      return this.rawSet.rbDominanceGroup(this.handle);\n    }\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n  }, {\n    key: \"setDominanceGroup\",\n    value: function setDominanceGroup(group) {\n      this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n    /**\n     * The number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     */\n  }, {\n    key: \"additionalSolverIterations\",\n    value: function additionalSolverIterations() {\n      return this.rawSet.rbAdditionalSolverIterations(this.handle);\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n  }, {\n    key: \"setAdditionalSolverIterations\",\n    value: function setAdditionalSolverIterations(iters) {\n      this.rawSet.rbSetAdditionalSolverIterations(this.handle, iters);\n    }\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n  }, {\n    key: \"enableCcd\",\n    value: function enableCcd(enabled) {\n      this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n  }, {\n    key: \"translation\",\n    value: function translation() {\n      var res = this.rawSet.rbTranslation(this.handle);\n      return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n  }, {\n    key: \"rotation\",\n    value: function rotation() {\n      var res = this.rawSet.rbRotation(this.handle);\n      return _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.fromRaw(res);\n    }\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n  }, {\n    key: \"nextTranslation\",\n    value: function nextTranslation() {\n      var res = this.rawSet.rbNextTranslation(this.handle);\n      return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n  }, {\n    key: \"nextRotation\",\n    value: function nextRotation() {\n      var res = this.rawSet.rbNextRotation(this.handle);\n      return _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.fromRaw(res);\n    }\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n  }, {\n    key: \"setTranslation\",\n    value: function setTranslation(tra, wakeUp) {\n      // #if DIM2\n      this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, wakeUp);\n      // #endif\n    }\n    /**\n     * Sets the linear velocity of this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n  }, {\n    key: \"setLinvel\",\n    value: function setLinvel(vel, wakeUp) {\n      var rawVel = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(vel);\n      this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n      rawVel.free();\n    }\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n  }, {\n    key: \"gravityScale\",\n    value: function gravityScale() {\n      return this.rawSet.rbGravityScale(this.handle);\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n  }, {\n    key: \"setGravityScale\",\n    value: function setGravityScale(factor, wakeUp) {\n      this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n  }, {\n    key: \"setRotation\",\n    value: function setRotation(angle, wakeUp) {\n      this.rawSet.rbSetRotation(this.handle, angle, wakeUp);\n    }\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n  }, {\n    key: \"setAngvel\",\n    value: function setAngvel(vel, wakeUp) {\n      this.rawSet.rbSetAngvel(this.handle, vel, wakeUp);\n    }\n    // #endif\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n  }, {\n    key: \"setNextKinematicTranslation\",\n    value: function setNextKinematicTranslation(t) {\n      // #if DIM2\n      this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y);\n      // #endif\n    }\n    // #if DIM2\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param angle - The kinematic rotation angle, in radians.\n     */\n  }, {\n    key: \"setNextKinematicRotation\",\n    value: function setNextKinematicRotation(angle) {\n      this.rawSet.rbSetNextKinematicRotation(this.handle, angle);\n    }\n    // #endif\n    /**\n     * The linear velocity of this rigid-body.\n     */\n  }, {\n    key: \"linvel\",\n    value: function linvel() {\n      return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n    // #if DIM2\n    /**\n     * The angular velocity of this rigid-body.\n     */\n  }, {\n    key: \"angvel\",\n    value: function angvel() {\n      return this.rawSet.rbAngvel(this.handle);\n    }\n    // #endif\n    /**\n     * The mass of this rigid-body.\n     */\n  }, {\n    key: \"mass\",\n    value: function mass() {\n      return this.rawSet.rbMass(this.handle);\n    }\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n  }, {\n    key: \"effectiveInvMass\",\n    value: function effectiveInvMass() {\n      return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n  }, {\n    key: \"invMass\",\n    value: function invMass() {\n      return this.rawSet.rbInvMass(this.handle);\n    }\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n  }, {\n    key: \"localCom\",\n    value: function localCom() {\n      return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n  }, {\n    key: \"worldCom\",\n    value: function worldCom() {\n      return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n    // #if DIM2\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n  }, {\n    key: \"invPrincipalInertiaSqrt\",\n    value: function invPrincipalInertiaSqrt() {\n      return this.rawSet.rbInvPrincipalInertiaSqrt(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n  }, {\n    key: \"principalInertia\",\n    value: function principalInertia() {\n      return this.rawSet.rbPrincipalInertia(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n  }, {\n    key: \"effectiveWorldInvInertiaSqrt\",\n    value: function effectiveWorldInvInertiaSqrt() {\n      return this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n  }, {\n    key: \"effectiveAngularInertia\",\n    value: function effectiveAngularInertia() {\n      return this.rawSet.rbEffectiveAngularInertia(this.handle);\n    }\n    // #endif\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n  }, {\n    key: \"sleep\",\n    value: function sleep() {\n      this.rawSet.rbSleep(this.handle);\n    }\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n  }, {\n    key: \"wakeUp\",\n    value: function wakeUp() {\n      this.rawSet.rbWakeUp(this.handle);\n    }\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n  }, {\n    key: \"isCcdEnabled\",\n    value: function isCcdEnabled() {\n      return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n  }, {\n    key: \"numColliders\",\n    value: function numColliders() {\n      return this.rawSet.rbNumColliders(this.handle);\n    }\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n  }, {\n    key: \"collider\",\n    value: function collider(i) {\n      return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n  }, {\n    key: \"setEnabled\",\n    value: function setEnabled(enabled) {\n      this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this rigid-body enabled?\n     */\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.rawSet.rbIsEnabled(this.handle);\n    }\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n  }, {\n    key: \"bodyType\",\n    value: function bodyType() {\n      return this.rawSet.rbBodyType(this.handle);\n    }\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n  }, {\n    key: \"setBodyType\",\n    value: function setBodyType(type, wakeUp) {\n      return this.rawSet.rbSetBodyType(this.handle, type, wakeUp);\n    }\n    /**\n     * Is this rigid-body sleeping?\n     */\n  }, {\n    key: \"isSleeping\",\n    value: function isSleeping() {\n      return this.rawSet.rbIsSleeping(this.handle);\n    }\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n  }, {\n    key: \"isMoving\",\n    value: function isMoving() {\n      return this.rawSet.rbIsMoving(this.handle);\n    }\n    /**\n     * Is this rigid-body static?\n     */\n  }, {\n    key: \"isFixed\",\n    value: function isFixed() {\n      return this.rawSet.rbIsFixed(this.handle);\n    }\n    /**\n     * Is this rigid-body kinematic?\n     */\n  }, {\n    key: \"isKinematic\",\n    value: function isKinematic() {\n      return this.rawSet.rbIsKinematic(this.handle);\n    }\n    /**\n     * Is this rigid-body dynamic?\n     */\n  }, {\n    key: \"isDynamic\",\n    value: function isDynamic() {\n      return this.rawSet.rbIsDynamic(this.handle);\n    }\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n  }, {\n    key: \"linearDamping\",\n    value: function linearDamping() {\n      return this.rawSet.rbLinearDamping(this.handle);\n    }\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n  }, {\n    key: \"angularDamping\",\n    value: function angularDamping() {\n      return this.rawSet.rbAngularDamping(this.handle);\n    }\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n  }, {\n    key: \"setLinearDamping\",\n    value: function setLinearDamping(factor) {\n      this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n  }, {\n    key: \"recomputeMassPropertiesFromColliders\",\n    value: function recomputeMassPropertiesFromColliders() {\n      this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);\n    }\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isn’t desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders’ contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n  }, {\n    key: \"setAdditionalMass\",\n    value: function setAdditionalMass(mass, wakeUp) {\n      this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders’ contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n  }, {\n    key: \"setAdditionalMassProperties\",\n    value: function setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia, wakeUp) {\n      var rawCom = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(centerOfMass);\n      this.rawSet.rbSetAdditionalMassProperties(this.handle, mass, rawCom, principalAngularInertia, wakeUp);\n      rawCom.free();\n    }\n    // #endif\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n  }, {\n    key: \"setAngularDamping\",\n    value: function setAngularDamping(factor) {\n      this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n  }, {\n    key: \"resetForces\",\n    value: function resetForces(wakeUp) {\n      this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n  }, {\n    key: \"resetTorques\",\n    value: function resetTorques(wakeUp) {\n      this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n  }, {\n    key: \"addForce\",\n    value: function addForce(force, wakeUp) {\n      var rawForce = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(force);\n      this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n      rawForce.free();\n    }\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n  }, {\n    key: \"applyImpulse\",\n    value: function applyImpulse(impulse, wakeUp) {\n      var rawImpulse = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(impulse);\n      this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n      rawImpulse.free();\n    }\n    // #if DIM2\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n  }, {\n    key: \"addTorque\",\n    value: function addTorque(torque, wakeUp) {\n      this.rawSet.rbAddTorque(this.handle, torque, wakeUp);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n  }, {\n    key: \"applyTorqueImpulse\",\n    value: function applyTorqueImpulse(torqueImpulse, wakeUp) {\n      this.rawSet.rbApplyTorqueImpulse(this.handle, torqueImpulse, wakeUp);\n    }\n    // #endif\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n  }, {\n    key: \"addForceAtPoint\",\n    value: function addForceAtPoint(force, point, wakeUp) {\n      var rawForce = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(force);\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n      this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n      rawForce.free();\n      rawPoint.free();\n    }\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n  }, {\n    key: \"applyImpulseAtPoint\",\n    value: function applyImpulseAtPoint(impulse, point, wakeUp) {\n      var rawImpulse = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(impulse);\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n      this.rawSet.rbApplyImpulseAtPoint(this.handle, rawImpulse, rawPoint, wakeUp);\n      rawImpulse.free();\n      rawPoint.free();\n    }\n  }]);\n  return RigidBody;\n}();\nvar RigidBodyDesc = /*#__PURE__*/function () {\n  function RigidBodyDesc(status) {\n    _classCallCheck(this, RigidBodyDesc);\n    this.enabled = true;\n    this.status = status;\n    this.translation = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.zeros();\n    this.rotation = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.identity();\n    this.gravityScale = 1.0;\n    this.linvel = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.zeros();\n    this.mass = 0.0;\n    this.massOnly = false;\n    this.centerOfMass = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.zeros();\n    this.translationsEnabledX = true;\n    this.translationsEnabledY = true;\n    // #if DIM2\n    this.angvel = 0.0;\n    this.principalAngularInertia = 0.0;\n    this.rotationsEnabled = true;\n    // #endif\n    this.linearDamping = 0.0;\n    this.angularDamping = 0.0;\n    this.canSleep = true;\n    this.sleeping = false;\n    this.ccdEnabled = false;\n    this.dominanceGroup = 0;\n    this.additionalSolverIterations = 0;\n  }\n  /**\n   * A rigid-body descriptor used to build a dynamic rigid-body.\n   */\n  _createClass(RigidBodyDesc, [{\n    key: \"setDominanceGroup\",\n    value: function setDominanceGroup(group) {\n      this.dominanceGroup = group;\n      return this;\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n  }, {\n    key: \"setAdditionalSolverIterations\",\n    value: function setAdditionalSolverIterations(iters) {\n      this.additionalSolverIterations = iters;\n      return this;\n    }\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled − If set to `false` the rigid-body will be disabled at creation.\n     */\n  }, {\n    key: \"setEnabled\",\n    value: function setEnabled(enabled) {\n      this.enabled = enabled;\n      return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     */\n  }, {\n    key: \"setTranslation\",\n    value: function setTranslation(x, y) {\n      if (typeof x != \"number\" || typeof y != \"number\") throw TypeError(\"The translation components must be numbers.\");\n      this.translation = {\n        x: x,\n        y: y\n      };\n      return this;\n    }\n    // #endif\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n  }, {\n    key: \"setRotation\",\n    value: function setRotation(rot) {\n      // #if DIM2\n      this.rotation = rot;\n      // #endif\n      return this;\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n  }, {\n    key: \"setGravityScale\",\n    value: function setGravityScale(scale) {\n      this.gravityScale = scale;\n      return this;\n    }\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     */\n  }, {\n    key: \"setAdditionalMass\",\n    value: function setAdditionalMass(mass) {\n      this.mass = mass;\n      this.massOnly = true;\n      return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     */\n  }, {\n    key: \"setLinvel\",\n    value: function setLinvel(x, y) {\n      if (typeof x != \"number\" || typeof y != \"number\") throw TypeError(\"The linvel components must be numbers.\");\n      this.linvel = {\n        x: x,\n        y: y\n      };\n      return this;\n    }\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n  }, {\n    key: \"setAngvel\",\n    value: function setAngvel(vel) {\n      this.angvel = vel;\n      return this;\n    }\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     * @param centerOfMass − The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia − The initial principal angular inertia of the rigid-body to create.\n     */\n  }, {\n    key: \"setAdditionalMassProperties\",\n    value: function setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia) {\n      this.mass = mass;\n      _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.copy(this.centerOfMass, centerOfMass);\n      this.principalAngularInertia = principalAngularInertia;\n      this.massOnly = false;\n      return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     */\n  }, {\n    key: \"enabledTranslations\",\n    value: function enabledTranslations(translationsEnabledX, translationsEnabledY) {\n      this.translationsEnabledX = translationsEnabledX;\n      this.translationsEnabledY = translationsEnabledY;\n      return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n  }, {\n    key: \"restrictTranslations\",\n    value: function restrictTranslations(translationsEnabledX, translationsEnabledY) {\n      return this.enabledTranslations(translationsEnabledX, translationsEnabledY);\n    }\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n  }, {\n    key: \"lockTranslations\",\n    value: function lockTranslations() {\n      return this.restrictTranslations(false, false);\n    }\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n  }, {\n    key: \"lockRotations\",\n    value: function lockRotations() {\n      this.rotationsEnabled = false;\n      return this;\n    }\n    // #endif\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n  }, {\n    key: \"setLinearDamping\",\n    value: function setLinearDamping(damping) {\n      this.linearDamping = damping;\n      return this;\n    }\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n  }, {\n    key: \"setAngularDamping\",\n    value: function setAngularDamping(damping) {\n      this.angularDamping = damping;\n      return this;\n    }\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n  }, {\n    key: \"setCanSleep\",\n    value: function setCanSleep(can) {\n      this.canSleep = can;\n      return this;\n    }\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n  }, {\n    key: \"setSleeping\",\n    value: function setSleeping(sleeping) {\n      this.sleeping = sleeping;\n      return this;\n    }\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n  }, {\n    key: \"setCcdEnabled\",\n    value: function setCcdEnabled(enabled) {\n      this.ccdEnabled = enabled;\n      return this;\n    }\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n  }, {\n    key: \"setUserData\",\n    value: function setUserData(data) {\n      this.userData = data;\n      return this;\n    }\n  }], [{\n    key: \"dynamic\",\n    value: function dynamic() {\n      return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n  }, {\n    key: \"kinematicPositionBased\",\n    value: function kinematicPositionBased() {\n      return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n  }, {\n    key: \"kinematicVelocityBased\",\n    value: function kinematicVelocityBased() {\n      return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n  }, {\n    key: \"fixed\",\n    value: function fixed() {\n      return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n  }, {\n    key: \"newDynamic\",\n    value: function newDynamic() {\n      return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n  }, {\n    key: \"newKinematicPositionBased\",\n    value: function newKinematicPositionBased() {\n      return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n  }, {\n    key: \"newKinematicVelocityBased\",\n    value: function newKinematicVelocityBased() {\n      return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n  }, {\n    key: \"newStatic\",\n    value: function newStatic() {\n      return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n  }]);\n  return RigidBodyDesc;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/dynamics/rigid_body.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js":
/*!********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RigidBodySet: () => (/* binding */ RigidBodySet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"./node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _rigid_body__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rigid_body */ \"./node_modules/@dimforge/rapier2d/dynamics/rigid_body.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _rigid_body__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _rigid_body__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nvar RigidBodySet = /*#__PURE__*/function () {\n  function RigidBodySet(raw) {\n    var _this = this;\n    _classCallCheck(this, RigidBodySet);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodySet();\n    this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n    // deserialize\n    if (raw) {\n      raw.forEachRigidBodyHandle(function (handle) {\n        _this.map.set(handle, new _rigid_body__WEBPACK_IMPORTED_MODULE_2__.RigidBody(raw, null, handle));\n      });\n    }\n  }\n  /**\n   * Release the WASM memory occupied by this rigid-body set.\n   */\n  _createClass(RigidBodySet, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n      if (!!this.map) {\n        this.map.clear();\n      }\n      this.map = undefined;\n    }\n    /**\n     * Internal method, do not call this explicitly.\n     */\n  }, {\n    key: \"finalizeDeserialization\",\n    value: function finalizeDeserialization(colliderSet) {\n      this.map.forEach(function (rb) {\n        return rb.finalizeDeserialization(colliderSet);\n      });\n    }\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n  }, {\n    key: \"createRigidBody\",\n    value: function createRigidBody(colliderSet, desc) {\n      var rawTra = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.translation);\n      var rawRot = _math__WEBPACK_IMPORTED_MODULE_3__.RotationOps.intoRaw(desc.rotation);\n      var rawLv = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.linvel);\n      var rawCom = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.centerOfMass);\n      var handle = this.raw.createRigidBody(desc.enabled, rawTra, rawRot, desc.gravityScale, desc.mass, desc.massOnly, rawCom, rawLv,\n      // #if DIM2\n      desc.angvel, desc.principalAngularInertia, desc.translationsEnabledX, desc.translationsEnabledY, desc.rotationsEnabled,\n      // #endif\n      desc.linearDamping, desc.angularDamping, desc.status, desc.canSleep, desc.sleeping, desc.ccdEnabled, desc.dominanceGroup, desc.additionalSolverIterations);\n      rawTra.free();\n      rawRot.free();\n      rawLv.free();\n      rawCom.free();\n      var body = new _rigid_body__WEBPACK_IMPORTED_MODULE_2__.RigidBody(this.raw, colliderSet, handle);\n      body.userData = desc.userData;\n      this.map.set(handle, body);\n      return body;\n    }\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(handle, islands, colliders, impulseJoints, multibodyJoints) {\n      // Unmap the entities that will be removed automatically because of the rigid-body removals.\n      for (var i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n        colliders.unmap(this.raw.rbCollider(handle, i));\n      }\n      impulseJoints.forEachJointHandleAttachedToRigidBody(handle, function (handle) {\n        return impulseJoints.unmap(handle);\n      });\n      multibodyJoints.forEachJointHandleAttachedToRigidBody(handle, function (handle) {\n        return multibodyJoints.unmap(handle);\n      });\n      // Remove the rigid-body.\n      this.raw.remove(handle, islands.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n      this.map[\"delete\"](handle);\n    }\n    /**\n     * The number of rigid-bodies on this set.\n     */\n  }, {\n    key: \"len\",\n    value: function len() {\n      return this.map.len();\n    }\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n  }, {\n    key: \"contains\",\n    value: function contains(handle) {\n      return this.get(handle) != null;\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n  }, {\n    key: \"get\",\n    value: function get(handle) {\n      return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      this.map.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n  }, {\n    key: \"forEachActiveRigidBody\",\n    value: function forEachActiveRigidBody(islands, f) {\n      var _this2 = this;\n      islands.forEachActiveRigidBodyHandle(function (handle) {\n        f(_this2.get(handle));\n      });\n    }\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      return this.map.getAll();\n    }\n  }]);\n  return RigidBodySet;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/exports.js":
/*!****************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/exports.js ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ActiveCollisionTypes),\n/* harmony export */   ActiveEvents: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.ActiveEvents),\n/* harmony export */   ActiveHooks: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.ActiveHooks),\n/* harmony export */   Ball: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Ball),\n/* harmony export */   BroadPhase: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.BroadPhase),\n/* harmony export */   CCDSolver: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.CCDSolver),\n/* harmony export */   Capsule: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Capsule),\n/* harmony export */   CharacterCollision: () => (/* reexport safe */ _control__WEBPACK_IMPORTED_MODULE_5__.CharacterCollision),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.CoefficientCombineRule),\n/* harmony export */   Collider: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Collider),\n/* harmony export */   ColliderDesc: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ColliderDesc),\n/* harmony export */   ColliderSet: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ColliderSet),\n/* harmony export */   ConvexPolygon: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Cuboid),\n/* harmony export */   DebugRenderBuffers: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.DebugRenderPipeline),\n/* harmony export */   EventQueue: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.EventQueue),\n/* harmony export */   FeatureType: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.FeatureType),\n/* harmony export */   FixedImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.FixedImpulseJoint),\n/* harmony export */   FixedMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.FixedMultibodyJoint),\n/* harmony export */   HalfSpace: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.HalfSpace),\n/* harmony export */   Heightfield: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Heightfield),\n/* harmony export */   ImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint),\n/* harmony export */   ImpulseJointSet: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.ImpulseJointSet),\n/* harmony export */   IntegrationParameters: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.IntegrationParameters),\n/* harmony export */   IslandManager: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.IslandManager),\n/* harmony export */   JointAxesMask: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.JointAxesMask),\n/* harmony export */   JointData: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.JointData),\n/* harmony export */   JointType: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.JointType),\n/* harmony export */   KinematicCharacterController: () => (/* reexport safe */ _control__WEBPACK_IMPORTED_MODULE_5__.KinematicCharacterController),\n/* harmony export */   MassPropsMode: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.MassPropsMode),\n/* harmony export */   MotorModel: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MotorModel),\n/* harmony export */   MultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint),\n/* harmony export */   MultibodyJointSet: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MultibodyJointSet),\n/* harmony export */   NarrowPhase: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.NarrowPhase),\n/* harmony export */   PhysicsPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.PhysicsPipeline),\n/* harmony export */   PointColliderProjection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.PointProjection),\n/* harmony export */   Polyline: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Polyline),\n/* harmony export */   PrismaticImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.PrismaticImpulseJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.PrismaticMultibodyJoint),\n/* harmony export */   QueryFilterFlags: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.QueryPipeline),\n/* harmony export */   Ray: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Ray),\n/* harmony export */   RayColliderIntersection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayColliderIntersection),\n/* harmony export */   RayColliderToi: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayColliderToi),\n/* harmony export */   RayIntersection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayIntersection),\n/* harmony export */   RevoluteImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RevoluteImpulseJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RevoluteMultibodyJoint),\n/* harmony export */   RigidBody: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodyDesc),\n/* harmony export */   RigidBodySet: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodySet),\n/* harmony export */   RigidBodyType: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodyType),\n/* harmony export */   RopeImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RopeImpulseJoint),\n/* harmony export */   RotationOps: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps),\n/* harmony export */   RoundConvexPolygon: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundTriangle),\n/* harmony export */   Segment: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Segment),\n/* harmony export */   SerializationPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.SerializationPipeline),\n/* harmony export */   Shape: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Shape),\n/* harmony export */   ShapeColliderTOI: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeColliderTOI),\n/* harmony export */   ShapeContact: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeContact),\n/* harmony export */   ShapeTOI: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeTOI),\n/* harmony export */   ShapeType: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeType),\n/* harmony export */   SolverFlags: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.SolverFlags),\n/* harmony export */   SpringImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.SpringImpulseJoint),\n/* harmony export */   TempContactForceEvent: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.TempContactForceEvent),\n/* harmony export */   TempContactManifold: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.TempContactManifold),\n/* harmony export */   TriMesh: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.TriMesh),\n/* harmony export */   Triangle: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Triangle),\n/* harmony export */   UnitImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.UnitImpulseJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.UnitMultibodyJoint),\n/* harmony export */   Vector2: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.Vector2),\n/* harmony export */   VectorOps: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps),\n/* harmony export */   World: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.World),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/index.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry */ \"./node_modules/@dimforge/rapier2d/geometry/index.js\");\n/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/index.js\");\n/* harmony import */ var _control__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./control */ \"./node_modules/@dimforge/rapier2d/control/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _dynamics__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _pipeline__WEBPACK_IMPORTED_MODULE_4__, _control__WEBPACK_IMPORTED_MODULE_5__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _dynamics__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _pipeline__WEBPACK_IMPORTED_MODULE_4__, _control__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\nfunction version() {\n  return (0,_raw__WEBPACK_IMPORTED_MODULE_0__.version)();\n}\n\n\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/exports.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/broad_phase.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/broad_phase.js ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BroadPhase: () => (/* binding */ BroadPhase)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nvar BroadPhase = /*#__PURE__*/function () {\n  function BroadPhase(raw) {\n    _classCallCheck(this, BroadPhase);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawBroadPhase();\n  }\n  /**\n   * Release the WASM memory occupied by this broad-phase.\n   */\n  _createClass(BroadPhase, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n    }\n  }]);\n  return BroadPhase;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/geometry/broad_phase.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/collider.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/collider.js ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* binding */ ActiveCollisionTypes),\n/* harmony export */   Collider: () => (/* binding */ Collider),\n/* harmony export */   ColliderDesc: () => (/* binding */ ColliderDesc),\n/* harmony export */   MassPropsMode: () => (/* binding */ MassPropsMode)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js\");\n/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/event_queue.js\");\n/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js\");\n/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shape */ \"./node_modules/@dimforge/rapier2d/geometry/shape.js\");\n/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ray */ \"./node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point */ \"./node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _toi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toi */ \"./node_modules/@dimforge/rapier2d/geometry/toi.js\");\n/* harmony import */ var _contact__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contact */ \"./node_modules/@dimforge/rapier2d/geometry/contact.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_shape__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _point__WEBPACK_IMPORTED_MODULE_2__, _toi__WEBPACK_IMPORTED_MODULE_3__, _contact__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_5__, _pipeline__WEBPACK_IMPORTED_MODULE_7__]);\n([_shape__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _point__WEBPACK_IMPORTED_MODULE_2__, _toi__WEBPACK_IMPORTED_MODULE_3__, _contact__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_5__, _pipeline__WEBPACK_IMPORTED_MODULE_7__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\n\n\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nvar ActiveCollisionTypes;\n(function (ActiveCollisionTypes) {\n  /**\n   * Enable collision-detection between a collider attached to a dynamic body\n   * and another collider attached to a dynamic body.\n   */\n  ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_DYNAMIC\"] = 1] = \"DYNAMIC_DYNAMIC\";\n  /**\n   * Enable collision-detection between a collider attached to a dynamic body\n   * and another collider attached to a kinematic body.\n   */\n  ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_KINEMATIC\"] = 12] = \"DYNAMIC_KINEMATIC\";\n  /**\n   * Enable collision-detection between a collider attached to a dynamic body\n   * and another collider attached to a fixed body (or not attached to any body).\n   */\n  ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_FIXED\"] = 2] = \"DYNAMIC_FIXED\";\n  /**\n   * Enable collision-detection between a collider attached to a kinematic body\n   * and another collider attached to a kinematic body.\n   */\n  ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_KINEMATIC\"] = 52224] = \"KINEMATIC_KINEMATIC\";\n  /**\n   * Enable collision-detection between a collider attached to a kinematic body\n   * and another collider attached to a fixed body (or not attached to any body).\n   */\n  ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_FIXED\"] = 8704] = \"KINEMATIC_FIXED\";\n  /**\n   * Enable collision-detection between a collider attached to a fixed body (or\n   * not attached to any body) and another collider attached to a fixed body (or\n   * not attached to any body).\n   */\n  ActiveCollisionTypes[ActiveCollisionTypes[\"FIXED_FIXED\"] = 32] = \"FIXED_FIXED\";\n  /**\n   * The default active collision types, enabling collisions between a dynamic body\n   * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n   */\n  ActiveCollisionTypes[ActiveCollisionTypes[\"DEFAULT\"] = 15] = \"DEFAULT\";\n  /**\n   * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n   */\n  ActiveCollisionTypes[ActiveCollisionTypes[\"ALL\"] = 60943] = \"ALL\";\n})(ActiveCollisionTypes || (ActiveCollisionTypes = {}));\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nvar Collider = /*#__PURE__*/function () {\n  function Collider(colliderSet, handle, parent, shape) {\n    _classCallCheck(this, Collider);\n    this.colliderSet = colliderSet;\n    this.handle = handle;\n    this._parent = parent;\n    this._shape = shape;\n  }\n  /** @internal */\n  _createClass(Collider, [{\n    key: \"finalizeDeserialization\",\n    value: function finalizeDeserialization(bodies) {\n      if (this.handle != null) {\n        this._parent = bodies.get(this.colliderSet.raw.coParent(this.handle));\n      }\n    }\n  }, {\n    key: \"ensureShapeIsCached\",\n    value: function ensureShapeIsCached() {\n      if (!this._shape) this._shape = _shape__WEBPACK_IMPORTED_MODULE_0__.Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n    /**\n     * The shape of this collider.\n     */\n  }, {\n    key: \"shape\",\n    get: function get() {\n      this.ensureShapeIsCached();\n      return this._shape;\n    }\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      return this.colliderSet.raw.contains(this.handle);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n  }, {\n    key: \"translation\",\n    value: function translation() {\n      return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.colliderSet.raw.coTranslation(this.handle));\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n  }, {\n    key: \"rotation\",\n    value: function rotation() {\n      return _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.fromRaw(this.colliderSet.raw.coRotation(this.handle));\n    }\n    /**\n     * Is this collider a sensor?\n     */\n  }, {\n    key: \"isSensor\",\n    value: function isSensor() {\n      return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n  }, {\n    key: \"setSensor\",\n    value: function setSensor(isSensor) {\n      this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The collider’s new shape.\n     */\n  }, {\n    key: \"setShape\",\n    value: function setShape(shape) {\n      var rawShape = shape.intoRaw();\n      this.colliderSet.raw.coSetShape(this.handle, rawShape);\n      rawShape.free();\n      this._shape = shape;\n    }\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body won’t be disabled automatically by this).\n     */\n  }, {\n    key: \"setEnabled\",\n    value: function setEnabled(enabled) {\n      this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this collider enabled?\n     */\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n  }, {\n    key: \"setRestitution\",\n    value: function setRestitution(restitution) {\n      this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n  }, {\n    key: \"setFriction\",\n    value: function setFriction(friction) {\n      this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n  }, {\n    key: \"frictionCombineRule\",\n    value: function frictionCombineRule() {\n      return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n  }, {\n    key: \"setFrictionCombineRule\",\n    value: function setFrictionCombineRule(rule) {\n      this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n  }, {\n    key: \"restitutionCombineRule\",\n    value: function restitutionCombineRule() {\n      return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n  }, {\n    key: \"setRestitutionCombineRule\",\n    value: function setRestitutionCombineRule(rule) {\n      this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n  }, {\n    key: \"setCollisionGroups\",\n    value: function setCollisionGroups(groups) {\n      this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n  }, {\n    key: \"setSolverGroups\",\n    value: function setSolverGroups(groups) {\n      this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n    /**\n     * Get the physics hooks active for this collider.\n     */\n  }, {\n    key: \"activeHooks\",\n    value: function activeHooks() {\n      return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n  }, {\n    key: \"setActiveHooks\",\n    value: function setActiveHooks(activeHooks) {\n      this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n    /**\n     * The events active for this collider.\n     */\n  }, {\n    key: \"activeEvents\",\n    value: function activeEvents() {\n      return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n  }, {\n    key: \"setActiveEvents\",\n    value: function setActiveEvents(activeEvents) {\n      this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n    /**\n     * Gets the collision types active for this collider.\n     */\n  }, {\n    key: \"activeCollisionTypes\",\n    value: function activeCollisionTypes() {\n      return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n  }, {\n    key: \"setContactForceEventThreshold\",\n    value: function setContactForceEventThreshold(threshold) {\n      return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, threshold);\n    }\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n  }, {\n    key: \"contactForceEventThreshold\",\n    value: function contactForceEventThreshold() {\n      return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n  }, {\n    key: \"setActiveCollisionTypes\",\n    value: function setActiveCollisionTypes(activeCollisionTypes) {\n      this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, activeCollisionTypes);\n    }\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n  }, {\n    key: \"setDensity\",\n    value: function setDensity(density) {\n      this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n  }, {\n    key: \"setMass\",\n    value: function setMass(mass) {\n      this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n    // #if DIM2\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n  }, {\n    key: \"setMassProperties\",\n    value: function setMassProperties(mass, centerOfMass, principalAngularInertia) {\n      var rawCom = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(centerOfMass);\n      this.colliderSet.raw.coSetMassProperties(this.handle, mass, rawCom, principalAngularInertia);\n      rawCom.free();\n    }\n    // #endif\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n  }, {\n    key: \"setTranslation\",\n    value: function setTranslation(tra) {\n      // #if DIM2\n      this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y);\n      // #endif\n    }\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n  }, {\n    key: \"setTranslationWrtParent\",\n    value: function setTranslationWrtParent(tra) {\n      // #if DIM2\n      this.colliderSet.raw.coSetTranslationWrtParent(this.handle, tra.x, tra.y);\n      // #endif\n    }\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this collider.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n  }, {\n    key: \"setRotation\",\n    value: function setRotation(angle) {\n      this.colliderSet.raw.coSetRotation(this.handle, angle);\n    }\n    /**\n     * Sets the rotation angle of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n  }, {\n    key: \"setRotationWrtParent\",\n    value: function setRotationWrtParent(angle) {\n      this.colliderSet.raw.coSetRotationWrtParent(this.handle, angle);\n    }\n    // #endif\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n  }, {\n    key: \"shapeType\",\n    value: function shapeType() {\n      return this.colliderSet.raw.coShapeType(this.handle);\n    }\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n  }, {\n    key: \"halfExtents\",\n    value: function halfExtents() {\n      return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));\n    }\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n  }, {\n    key: \"setHalfExtents\",\n    value: function setHalfExtents(newHalfExtents) {\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(newHalfExtents);\n      this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n  }, {\n    key: \"radius\",\n    value: function radius() {\n      return this.colliderSet.raw.coRadius(this.handle);\n    }\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n  }, {\n    key: \"setRadius\",\n    value: function setRadius(newRadius) {\n      this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n  }, {\n    key: \"roundRadius\",\n    value: function roundRadius() {\n      return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n  }, {\n    key: \"setRoundRadius\",\n    value: function setRoundRadius(newBorderRadius) {\n      this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n  }, {\n    key: \"halfHeight\",\n    value: function halfHeight() {\n      return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n  }, {\n    key: \"setHalfHeight\",\n    value: function setHalfHeight(newHalfheight) {\n      this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n  }, {\n    key: \"vertices\",\n    value: function vertices() {\n      return this.colliderSet.raw.coVertices(this.handle);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n  }, {\n    key: \"indices\",\n    value: function indices() {\n      return this.colliderSet.raw.coIndices(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n  }, {\n    key: \"heightfieldHeights\",\n    value: function heightfieldHeights() {\n      return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n  }, {\n    key: \"heightfieldScale\",\n    value: function heightfieldScale() {\n      var scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n      return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(scale);\n    }\n    /**\n     * The rigid-body this collider is attached to.\n     */\n  }, {\n    key: \"parent\",\n    value: function parent() {\n      return this._parent;\n    }\n    /**\n     * The friction coefficient of this collider.\n     */\n  }, {\n    key: \"friction\",\n    value: function friction() {\n      return this.colliderSet.raw.coFriction(this.handle);\n    }\n    /**\n     * The restitution coefficient of this collider.\n     */\n  }, {\n    key: \"restitution\",\n    value: function restitution() {\n      return this.colliderSet.raw.coRestitution(this.handle);\n    }\n    /**\n     * The density of this collider.\n     */\n  }, {\n    key: \"density\",\n    value: function density() {\n      return this.colliderSet.raw.coDensity(this.handle);\n    }\n    /**\n     * The mass of this collider.\n     */\n  }, {\n    key: \"mass\",\n    value: function mass() {\n      return this.colliderSet.raw.coMass(this.handle);\n    }\n    /**\n     * The volume of this collider.\n     */\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      return this.colliderSet.raw.coVolume(this.handle);\n    }\n    /**\n     * The collision groups of this collider.\n     */\n  }, {\n    key: \"collisionGroups\",\n    value: function collisionGroups() {\n      return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n    /**\n     * The solver groups of this collider.\n     */\n  }, {\n    key: \"solverGroups\",\n    value: function solverGroups() {\n      return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n      var result = this.colliderSet.raw.coContainsPoint(this.handle, rawPoint);\n      rawPoint.free();\n      return result;\n    }\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n  }, {\n    key: \"projectPoint\",\n    value: function projectPoint(point, solid) {\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n      var result = _point__WEBPACK_IMPORTED_MODULE_2__.PointProjection.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid));\n      rawPoint.free();\n      return result;\n    }\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n  }, {\n    key: \"intersectsRay\",\n    value: function intersectsRay(ray, maxToi) {\n      var rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n      var rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n      var result = this.colliderSet.raw.coIntersectsRay(this.handle, rawOrig, rawDir, maxToi);\n      rawOrig.free();\n      rawDir.free();\n      return result;\n    }\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exist that penetration state.\n     */\n  }, {\n    key: \"castShape\",\n    value: function castShape(collider1Vel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi, stopAtPenetration) {\n      var rawCollider1Vel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(collider1Vel);\n      var rawShape2Pos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shape2Pos);\n      var rawShape2Rot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shape2Rot);\n      var rawShape2Vel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shape2Vel);\n      var rawShape2 = shape2.intoRaw();\n      var result = _toi__WEBPACK_IMPORTED_MODULE_3__.ShapeTOI.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, rawCollider1Vel, rawShape2, rawShape2Pos, rawShape2Rot, rawShape2Vel, maxToi, stopAtPenetration));\n      rawCollider1Vel.free();\n      rawShape2Pos.free();\n      rawShape2Rot.free();\n      rawShape2Vel.free();\n      rawShape2.free();\n      return result;\n    }\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exist that penetration state.\n     */\n  }, {\n    key: \"castCollider\",\n    value: function castCollider(collider1Vel, collider2, collider2Vel, maxToi, stopAtPenetration) {\n      var rawCollider1Vel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(collider1Vel);\n      var rawCollider2Vel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(collider2Vel);\n      var result = _toi__WEBPACK_IMPORTED_MODULE_3__.ShapeColliderTOI.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, rawCollider1Vel, collider2.handle, rawCollider2Vel, maxToi, stopAtPenetration));\n      rawCollider1Vel.free();\n      rawCollider2Vel.free();\n      return result;\n    }\n  }, {\n    key: \"intersectsShape\",\n    value: function intersectsShape(shape2, shapePos2, shapeRot2) {\n      var rawPos2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos2);\n      var rawRot2 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot2);\n      var rawShape2 = shape2.intoRaw();\n      var result = this.colliderSet.raw.coIntersectsShape(this.handle, rawShape2, rawPos2, rawRot2);\n      rawPos2.free();\n      rawRot2.free();\n      rawShape2.free();\n      return result;\n    }\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n  }, {\n    key: \"contactShape\",\n    value: function contactShape(shape2, shape2Pos, shape2Rot, prediction) {\n      var rawPos2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shape2Pos);\n      var rawRot2 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shape2Rot);\n      var rawShape2 = shape2.intoRaw();\n      var result = _contact__WEBPACK_IMPORTED_MODULE_4__.ShapeContact.fromRaw(this.colliderSet.raw.coContactShape(this.handle, rawShape2, rawPos2, rawRot2, prediction));\n      rawPos2.free();\n      rawRot2.free();\n      rawShape2.free();\n      return result;\n    }\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n  }, {\n    key: \"contactCollider\",\n    value: function contactCollider(collider2, prediction) {\n      var result = _contact__WEBPACK_IMPORTED_MODULE_4__.ShapeContact.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, collider2.handle, prediction));\n      return result;\n    }\n    /*\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n  }, {\n    key: \"castRay\",\n    value: function castRay(ray, maxToi, solid) {\n      var rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n      var rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n      var result = this.colliderSet.raw.coCastRay(this.handle, rawOrig, rawDir, maxToi, solid);\n      rawOrig.free();\n      rawDir.free();\n      return result;\n    }\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n  }, {\n    key: \"castRayAndGetNormal\",\n    value: function castRayAndGetNormal(ray, maxToi, solid) {\n      var rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n      var rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n      var result = _ray__WEBPACK_IMPORTED_MODULE_5__.RayIntersection.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, rawOrig, rawDir, maxToi, solid));\n      rawOrig.free();\n      rawDir.free();\n      return result;\n    }\n  }]);\n  return Collider;\n}();\nvar MassPropsMode;\n(function (MassPropsMode) {\n  MassPropsMode[MassPropsMode[\"Density\"] = 0] = \"Density\";\n  MassPropsMode[MassPropsMode[\"Mass\"] = 1] = \"Mass\";\n  MassPropsMode[MassPropsMode[\"MassProps\"] = 2] = \"MassProps\";\n})(MassPropsMode || (MassPropsMode = {}));\nvar ColliderDesc = /*#__PURE__*/function () {\n  /**\n   * Initializes a collider descriptor from the collision shape.\n   *\n   * @param shape - The shape of the collider being built.\n   */\n  function ColliderDesc(shape) {\n    _classCallCheck(this, ColliderDesc);\n    this.enabled = true;\n    this.shape = shape;\n    this.massPropsMode = MassPropsMode.Density;\n    this.density = 1.0;\n    this.friction = 0.5;\n    this.restitution = 0.0;\n    this.rotation = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.identity();\n    this.translation = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.zeros();\n    this.isSensor = false;\n    this.collisionGroups = 4294967295;\n    this.solverGroups = 4294967295;\n    this.frictionCombineRule = _dynamics__WEBPACK_IMPORTED_MODULE_6__.CoefficientCombineRule.Average;\n    this.restitutionCombineRule = _dynamics__WEBPACK_IMPORTED_MODULE_6__.CoefficientCombineRule.Average;\n    this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n    this.activeEvents = _pipeline__WEBPACK_IMPORTED_MODULE_7__.ActiveEvents.NONE;\n    this.activeHooks = _pipeline__WEBPACK_IMPORTED_MODULE_8__.ActiveHooks.NONE;\n    this.mass = 0.0;\n    this.centerOfMass = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.zeros();\n    this.contactForceEventThreshold = 0.0;\n    // #if DIM2\n    this.principalAngularInertia = 0.0;\n    this.rotationsEnabled = true;\n    // #endif\n  }\n  /**\n   * Create a new collider descriptor with a ball shape.\n   *\n   * @param radius - The radius of the ball.\n   */\n  _createClass(ColliderDesc, [{\n    key: \"setTranslation\",\n    value:\n    // #endif\n    // #if DIM2\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    function setTranslation(x, y) {\n      if (typeof x != \"number\" || typeof y != \"number\") throw TypeError(\"The translation components must be numbers.\");\n      this.translation = {\n        x: x,\n        y: y\n      };\n      return this;\n    }\n    // #endif\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n  }, {\n    key: \"setRotation\",\n    value: function setRotation(rot) {\n      // #if DIM2\n      this.rotation = rot;\n      // #endif\n      return this;\n    }\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n  }, {\n    key: \"setSensor\",\n    value: function setSensor(sensor) {\n      this.isSensor = sensor;\n      return this;\n    }\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled − If set to `false` the collider will be disabled at creation.\n     */\n  }, {\n    key: \"setEnabled\",\n    value: function setEnabled(enabled) {\n      this.enabled = enabled;\n      return this;\n    }\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the collider’s shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n  }, {\n    key: \"setDensity\",\n    value: function setDensity(density) {\n      this.massPropsMode = MassPropsMode.Density;\n      this.density = density;\n      return this;\n    }\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the collider’s shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n  }, {\n    key: \"setMass\",\n    value: function setMass(mass) {\n      this.massPropsMode = MassPropsMode.Mass;\n      this.mass = mass;\n      return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass − The mass of the collider to create.\n     * @param centerOfMass − The center-of-mass of the collider to create.\n     * @param principalAngularInertia − The principal angular inertia of the collider to create.\n     */\n  }, {\n    key: \"setMassProperties\",\n    value: function setMassProperties(mass, centerOfMass, principalAngularInertia) {\n      this.massPropsMode = MassPropsMode.MassProps;\n      this.mass = mass;\n      _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.copy(this.centerOfMass, centerOfMass);\n      this.principalAngularInertia = principalAngularInertia;\n      return this;\n    }\n    // #endif\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n  }, {\n    key: \"setRestitution\",\n    value: function setRestitution(restitution) {\n      this.restitution = restitution;\n      return this;\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n  }, {\n    key: \"setFriction\",\n    value: function setFriction(friction) {\n      this.friction = friction;\n      return this;\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n  }, {\n    key: \"setFrictionCombineRule\",\n    value: function setFrictionCombineRule(rule) {\n      this.frictionCombineRule = rule;\n      return this;\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n  }, {\n    key: \"setRestitutionCombineRule\",\n    value: function setRestitutionCombineRule(rule) {\n      this.restitutionCombineRule = rule;\n      return this;\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n  }, {\n    key: \"setCollisionGroups\",\n    value: function setCollisionGroups(groups) {\n      this.collisionGroups = groups;\n      return this;\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n  }, {\n    key: \"setSolverGroups\",\n    value: function setSolverGroups(groups) {\n      this.solverGroups = groups;\n      return this;\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n  }, {\n    key: \"setActiveHooks\",\n    value: function setActiveHooks(activeHooks) {\n      this.activeHooks = activeHooks;\n      return this;\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n  }, {\n    key: \"setActiveEvents\",\n    value: function setActiveEvents(activeEvents) {\n      this.activeEvents = activeEvents;\n      return this;\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n  }, {\n    key: \"setActiveCollisionTypes\",\n    value: function setActiveCollisionTypes(activeCollisionTypes) {\n      this.activeCollisionTypes = activeCollisionTypes;\n      return this;\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n  }, {\n    key: \"setContactForceEventThreshold\",\n    value: function setContactForceEventThreshold(threshold) {\n      this.contactForceEventThreshold = threshold;\n      return this;\n    }\n  }], [{\n    key: \"ball\",\n    value: function ball(radius) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Ball(radius);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n  }, {\n    key: \"capsule\",\n    value: function capsule(halfHeight, radius) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Capsule(halfHeight, radius);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n  }, {\n    key: \"segment\",\n    value: function segment(a, b) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Segment(a, b);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n  }, {\n    key: \"triangle\",\n    value: function triangle(a, b, c) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Triangle(a, b, c);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n  }, {\n    key: \"roundTriangle\",\n    value: function roundTriangle(a, b, c, borderRadius) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.RoundTriangle(a, b, c, borderRadius);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n  }, {\n    key: \"polyline\",\n    value: function polyline(vertices, indices) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Polyline(vertices, indices);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n  }, {\n    key: \"trimesh\",\n    value: function trimesh(vertices, indices) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.TriMesh(vertices, indices);\n      return new ColliderDesc(shape);\n    }\n    // #if DIM2\n    /**\n     * Creates a new collider descriptor with a rectangular shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     */\n  }, {\n    key: \"cuboid\",\n    value: function cuboid(hx, hy) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Cuboid(hx, hy);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n  }, {\n    key: \"roundCuboid\",\n    value: function roundCuboid(hx, hy, borderRadius) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.RoundCuboid(hx, hy, borderRadius);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider description with a halfspace (infinite plane) shape.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n  }, {\n    key: \"halfspace\",\n    value: function halfspace(normal) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.HalfSpace(normal);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param heights - The heights of the heightfield, along its local `y` axis.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n  }, {\n    key: \"heightfield\",\n    value: function heightfield(heights, scale) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Heightfield(heights, scale);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n  }, {\n    key: \"convexHull\",\n    value: function convexHull(points) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.ConvexPolygon(points, false);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n  }, {\n    key: \"convexPolyline\",\n    value: function convexPolyline(vertices) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.ConvexPolygon(vertices, true);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor. A\n     * border is added to that convex polygon to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polygon.\n     */\n  }, {\n    key: \"roundConvexHull\",\n    value: function roundConvexHull(points, borderRadius) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.RoundConvexPolygon(points, borderRadius, false);\n      return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n  }, {\n    key: \"roundConvexPolyline\",\n    value: function roundConvexPolyline(vertices, borderRadius) {\n      var shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.RoundConvexPolygon(vertices, borderRadius, true);\n      return new ColliderDesc(shape);\n    }\n  }]);\n  return ColliderDesc;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/geometry/collider.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/collider_set.js":
/*!******************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/collider_set.js ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColliderSet: () => (/* binding */ ColliderSet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"./node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _collider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collider */ \"./node_modules/@dimforge/rapier2d/geometry/collider.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _collider__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _collider__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nvar ColliderSet = /*#__PURE__*/function () {\n  function ColliderSet(raw) {\n    var _this = this;\n    _classCallCheck(this, ColliderSet);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawColliderSet();\n    this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n    // Initialize the map with the existing elements, if any.\n    if (raw) {\n      raw.forEachColliderHandle(function (handle) {\n        _this.map.set(handle, new _collider__WEBPACK_IMPORTED_MODULE_2__.Collider(_this, handle, null));\n      });\n    }\n  }\n  /**\n   * Release the WASM memory occupied by this collider set.\n   */\n  _createClass(ColliderSet, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n      if (!!this.map) {\n        this.map.clear();\n      }\n      this.map = undefined;\n    }\n    /** @internal */\n  }, {\n    key: \"castClosure\",\n    value: function castClosure(f) {\n      var _this2 = this;\n      return function (handle) {\n        if (!!f) {\n          return f(_this2.get(handle));\n        } else {\n          return undefined;\n        }\n      };\n    }\n    /** @internal */\n  }, {\n    key: \"finalizeDeserialization\",\n    value: function finalizeDeserialization(bodies) {\n      this.map.forEach(function (collider) {\n        return collider.finalizeDeserialization(bodies);\n      });\n    }\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n  }, {\n    key: \"createCollider\",\n    value: function createCollider(bodies, desc, parentHandle) {\n      var hasParent = parentHandle != undefined && parentHandle != null;\n      if (hasParent && isNaN(parentHandle)) throw Error(\"Cannot create a collider with a parent rigid-body handle that is not a number.\");\n      var rawShape = desc.shape.intoRaw();\n      var rawTra = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.translation);\n      var rawRot = _math__WEBPACK_IMPORTED_MODULE_3__.RotationOps.intoRaw(desc.rotation);\n      var rawCom = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.centerOfMass);\n      var handle = this.raw.createCollider(desc.enabled, rawShape, rawTra, rawRot, desc.massPropsMode, desc.mass, rawCom,\n      // #if DIM2\n      desc.principalAngularInertia,\n      // #endif\n      desc.density, desc.friction, desc.restitution, desc.frictionCombineRule, desc.restitutionCombineRule, desc.isSensor, desc.collisionGroups, desc.solverGroups, desc.activeCollisionTypes, desc.activeHooks, desc.activeEvents, desc.contactForceEventThreshold, hasParent, hasParent ? parentHandle : 0, bodies.raw);\n      rawShape.free();\n      rawTra.free();\n      rawRot.free();\n      rawCom.free();\n      var parent = hasParent ? bodies.get(parentHandle) : null;\n      var collider = new _collider__WEBPACK_IMPORTED_MODULE_2__.Collider(this, handle, parent, desc.shape);\n      this.map.set(handle, collider);\n      return collider;\n    }\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(handle, islands, bodies, wakeUp) {\n      this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n      this.unmap(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n  }, {\n    key: \"unmap\",\n    value: function unmap(handle) {\n      this.map[\"delete\"](handle);\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n  }, {\n    key: \"get\",\n    value: function get(handle) {\n      return this.map.get(handle);\n    }\n    /**\n     * The number of colliders on this set.\n     */\n  }, {\n    key: \"len\",\n    value: function len() {\n      return this.map.len();\n    }\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n  }, {\n    key: \"contains\",\n    value: function contains(handle) {\n      return this.get(handle) != null;\n    }\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      this.map.forEach(f);\n    }\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      return this.map.getAll();\n    }\n  }]);\n  return ColliderSet;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/geometry/collider_set.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/contact.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/contact.js ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShapeContact: () => (/* binding */ ShapeContact)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n/**\n * The contact info between two shapes.\n */\nvar ShapeContact = /*#__PURE__*/function () {\n  function ShapeContact(dist, point1, point2, normal1, normal2) {\n    _classCallCheck(this, ShapeContact);\n    this.distance = dist;\n    this.point1 = point1;\n    this.point2 = point2;\n    this.normal1 = normal1;\n    this.normal2 = normal2;\n  }\n  _createClass(ShapeContact, null, [{\n    key: \"fromRaw\",\n    value: function fromRaw(raw) {\n      if (!raw) return null;\n      var result = new ShapeContact(raw.distance(), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point2()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal2()));\n      raw.free();\n      return result;\n    }\n  }]);\n  return ShapeContact;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/geometry/contact.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/feature.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/feature.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeatureType: () => (/* binding */ FeatureType)\n/* harmony export */ });\n// #if DIM2\nvar FeatureType;\n(function (FeatureType) {\n  FeatureType[FeatureType[\"Vertex\"] = 0] = \"Vertex\";\n  FeatureType[FeatureType[\"Face\"] = 1] = \"Face\";\n  FeatureType[FeatureType[\"Unknown\"] = 2] = \"Unknown\";\n})(FeatureType || (FeatureType = {}));\n// #endif\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/geometry/feature.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/index.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.ActiveCollisionTypes),\n/* harmony export */   Ball: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Ball),\n/* harmony export */   BroadPhase: () => (/* reexport safe */ _broad_phase__WEBPACK_IMPORTED_MODULE_0__.BroadPhase),\n/* harmony export */   Capsule: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Capsule),\n/* harmony export */   Collider: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.Collider),\n/* harmony export */   ColliderDesc: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.ColliderDesc),\n/* harmony export */   ColliderSet: () => (/* reexport safe */ _collider_set__WEBPACK_IMPORTED_MODULE_4__.ColliderSet),\n/* harmony export */   ConvexPolygon: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Cuboid),\n/* harmony export */   FeatureType: () => (/* reexport safe */ _feature__WEBPACK_IMPORTED_MODULE_5__.FeatureType),\n/* harmony export */   HalfSpace: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.HalfSpace),\n/* harmony export */   Heightfield: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Heightfield),\n/* harmony export */   MassPropsMode: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.MassPropsMode),\n/* harmony export */   NarrowPhase: () => (/* reexport safe */ _narrow_phase__WEBPACK_IMPORTED_MODULE_1__.NarrowPhase),\n/* harmony export */   PointColliderProjection: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__.PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__.PointProjection),\n/* harmony export */   Polyline: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Polyline),\n/* harmony export */   Ray: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.Ray),\n/* harmony export */   RayColliderIntersection: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayColliderIntersection),\n/* harmony export */   RayColliderToi: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayColliderToi),\n/* harmony export */   RayIntersection: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayIntersection),\n/* harmony export */   RoundConvexPolygon: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundTriangle),\n/* harmony export */   Segment: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Segment),\n/* harmony export */   Shape: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Shape),\n/* harmony export */   ShapeColliderTOI: () => (/* reexport safe */ _toi__WEBPACK_IMPORTED_MODULE_8__.ShapeColliderTOI),\n/* harmony export */   ShapeContact: () => (/* reexport safe */ _contact__WEBPACK_IMPORTED_MODULE_9__.ShapeContact),\n/* harmony export */   ShapeTOI: () => (/* reexport safe */ _toi__WEBPACK_IMPORTED_MODULE_8__.ShapeTOI),\n/* harmony export */   ShapeType: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.ShapeType),\n/* harmony export */   TempContactManifold: () => (/* reexport safe */ _narrow_phase__WEBPACK_IMPORTED_MODULE_1__.TempContactManifold),\n/* harmony export */   TriMesh: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.TriMesh),\n/* harmony export */   Triangle: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Triangle)\n/* harmony export */ });\n/* harmony import */ var _broad_phase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./broad_phase */ \"./node_modules/@dimforge/rapier2d/geometry/broad_phase.js\");\n/* harmony import */ var _narrow_phase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./narrow_phase */ \"./node_modules/@dimforge/rapier2d/geometry/narrow_phase.js\");\n/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shape */ \"./node_modules/@dimforge/rapier2d/geometry/shape.js\");\n/* harmony import */ var _collider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./collider */ \"./node_modules/@dimforge/rapier2d/geometry/collider.js\");\n/* harmony import */ var _collider_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./collider_set */ \"./node_modules/@dimforge/rapier2d/geometry/collider_set.js\");\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./feature */ \"./node_modules/@dimforge/rapier2d/geometry/feature.js\");\n/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ray */ \"./node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./point */ \"./node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _toi__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./toi */ \"./node_modules/@dimforge/rapier2d/geometry/toi.js\");\n/* harmony import */ var _contact__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./contact */ \"./node_modules/@dimforge/rapier2d/geometry/contact.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_broad_phase__WEBPACK_IMPORTED_MODULE_0__, _narrow_phase__WEBPACK_IMPORTED_MODULE_1__, _shape__WEBPACK_IMPORTED_MODULE_2__, _collider__WEBPACK_IMPORTED_MODULE_3__, _collider_set__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_6__, _point__WEBPACK_IMPORTED_MODULE_7__, _toi__WEBPACK_IMPORTED_MODULE_8__, _contact__WEBPACK_IMPORTED_MODULE_9__]);\n([_broad_phase__WEBPACK_IMPORTED_MODULE_0__, _narrow_phase__WEBPACK_IMPORTED_MODULE_1__, _shape__WEBPACK_IMPORTED_MODULE_2__, _collider__WEBPACK_IMPORTED_MODULE_3__, _collider_set__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_6__, _point__WEBPACK_IMPORTED_MODULE_7__, _toi__WEBPACK_IMPORTED_MODULE_8__, _contact__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/geometry/index.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/narrow_phase.js":
/*!******************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/narrow_phase.js ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NarrowPhase: () => (/* binding */ NarrowPhase),\n/* harmony export */   TempContactManifold: () => (/* binding */ TempContactManifold)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nvar NarrowPhase = /*#__PURE__*/function () {\n  function NarrowPhase(raw) {\n    _classCallCheck(this, NarrowPhase);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawNarrowPhase();\n    this.tempManifold = new TempContactManifold(null);\n  }\n  /**\n   * Release the WASM memory occupied by this narrow-phase.\n   */\n  _createClass(NarrowPhase, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n  }, {\n    key: \"contactPairsWith\",\n    value: function contactPairsWith(collider1, f) {\n      this.raw.contact_pairs_with(collider1, f);\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n  }, {\n    key: \"intersectionPairsWith\",\n    value: function intersectionPairsWith(collider1, f) {\n      this.raw.intersection_pairs_with(collider1, f);\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n  }, {\n    key: \"contactPair\",\n    value: function contactPair(collider1, collider2, f) {\n      var rawPair = this.raw.contact_pair(collider1, collider2);\n      if (!!rawPair) {\n        var flipped = rawPair.collider1() != collider1;\n        var i;\n        for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n          this.tempManifold.raw = rawPair.contactManifold(i);\n          if (!!this.tempManifold.raw) {\n            f(this.tempManifold, flipped);\n          }\n          // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n          //         at the next timestep. So we must be sure to free the pair here\n          //         to avoid unsoundness in the Rust code.\n          this.tempManifold.free();\n        }\n        rawPair.free();\n      }\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n  }, {\n    key: \"intersectionPair\",\n    value: function intersectionPair(collider1, collider2) {\n      return this.raw.intersection_pair(collider1, collider2);\n    }\n  }]);\n  return NarrowPhase;\n}();\nvar TempContactManifold = /*#__PURE__*/function () {\n  function TempContactManifold(raw) {\n    _classCallCheck(this, TempContactManifold);\n    this.raw = raw;\n  }\n  _createClass(TempContactManifold, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n    }\n  }, {\n    key: \"normal\",\n    value: function normal() {\n      return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.normal());\n    }\n  }, {\n    key: \"localNormal1\",\n    value: function localNormal1() {\n      return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.local_n1());\n    }\n  }, {\n    key: \"localNormal2\",\n    value: function localNormal2() {\n      return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.local_n2());\n    }\n  }, {\n    key: \"subshape1\",\n    value: function subshape1() {\n      return this.raw.subshape1();\n    }\n  }, {\n    key: \"subshape2\",\n    value: function subshape2() {\n      return this.raw.subshape2();\n    }\n  }, {\n    key: \"numContacts\",\n    value: function numContacts() {\n      return this.raw.num_contacts();\n    }\n  }, {\n    key: \"localContactPoint1\",\n    value: function localContactPoint1(i) {\n      return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n  }, {\n    key: \"localContactPoint2\",\n    value: function localContactPoint2(i) {\n      return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n  }, {\n    key: \"contactDist\",\n    value: function contactDist(i) {\n      return this.raw.contact_dist(i);\n    }\n  }, {\n    key: \"contactFid1\",\n    value: function contactFid1(i) {\n      return this.raw.contact_fid1(i);\n    }\n  }, {\n    key: \"contactFid2\",\n    value: function contactFid2(i) {\n      return this.raw.contact_fid2(i);\n    }\n  }, {\n    key: \"contactImpulse\",\n    value: function contactImpulse(i) {\n      return this.raw.contact_impulse(i);\n    }\n    // #if DIM2\n  }, {\n    key: \"contactTangentImpulse\",\n    value: function contactTangentImpulse(i) {\n      return this.raw.contact_tangent_impulse(i);\n    }\n    // #endif\n  }, {\n    key: \"numSolverContacts\",\n    value: function numSolverContacts() {\n      return this.raw.num_solver_contacts();\n    }\n  }, {\n    key: \"solverContactPoint\",\n    value: function solverContactPoint(i) {\n      return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n  }, {\n    key: \"solverContactDist\",\n    value: function solverContactDist(i) {\n      return this.raw.solver_contact_dist(i);\n    }\n  }, {\n    key: \"solverContactFriction\",\n    value: function solverContactFriction(i) {\n      return this.raw.solver_contact_friction(i);\n    }\n  }, {\n    key: \"solverContactRestitution\",\n    value: function solverContactRestitution(i) {\n      return this.raw.solver_contact_restitution(i);\n    }\n  }, {\n    key: \"solverContactTangentVelocity\",\n    value: function solverContactTangentVelocity(i) {\n      return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n  }]);\n  return TempContactManifold;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/geometry/narrow_phase.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/point.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/point.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PointColliderProjection: () => (/* binding */ PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* binding */ PointProjection)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature */ \"./node_modules/@dimforge/rapier2d/geometry/feature.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * The projection of a point on a collider.\n */\nvar PointProjection = /*#__PURE__*/function () {\n  function PointProjection(point, isInside) {\n    _classCallCheck(this, PointProjection);\n    this.point = point;\n    this.isInside = isInside;\n  }\n  _createClass(PointProjection, null, [{\n    key: \"fromRaw\",\n    value: function fromRaw(raw) {\n      if (!raw) return null;\n      var result = new PointProjection(_math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point()), raw.isInside());\n      raw.free();\n      return result;\n    }\n  }]);\n  return PointProjection;\n}();\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nvar PointColliderProjection = /*#__PURE__*/function () {\n  function PointColliderProjection(collider, point, isInside, featureType, featureId) {\n    _classCallCheck(this, PointColliderProjection);\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    this.featureType = _feature__WEBPACK_IMPORTED_MODULE_1__.FeatureType.Unknown;\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    this.featureId = undefined;\n    this.collider = collider;\n    this.point = point;\n    this.isInside = isInside;\n    if (featureId !== undefined) this.featureId = featureId;\n    if (featureType !== undefined) this.featureType = featureType;\n  }\n  _createClass(PointColliderProjection, null, [{\n    key: \"fromRaw\",\n    value: function fromRaw(colliderSet, raw) {\n      if (!raw) return null;\n      var result = new PointColliderProjection(colliderSet.get(raw.colliderHandle()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point()), raw.isInside(), raw.featureType(), raw.featureId());\n      raw.free();\n      return result;\n    }\n  }]);\n  return PointColliderProjection;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/geometry/point.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/ray.js":
/*!*********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/ray.js ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ray: () => (/* binding */ Ray),\n/* harmony export */   RayColliderIntersection: () => (/* binding */ RayColliderIntersection),\n/* harmony export */   RayColliderToi: () => (/* binding */ RayColliderToi),\n/* harmony export */   RayIntersection: () => (/* binding */ RayIntersection)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature */ \"./node_modules/@dimforge/rapier2d/geometry/feature.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_1__]);\n_math__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * A ray. This is a directed half-line.\n */\nvar Ray = /*#__PURE__*/function () {\n  /**\n   * Builds a ray from its origin and direction.\n   *\n   * @param origin - The ray's starting point.\n   * @param dir - The ray's direction of propagation.\n   */\n  function Ray(origin, dir) {\n    _classCallCheck(this, Ray);\n    this.origin = origin;\n    this.dir = dir;\n  }\n  _createClass(Ray, [{\n    key: \"pointAt\",\n    value: function pointAt(t) {\n      return {\n        x: this.origin.x + this.dir.x * t,\n        y: this.origin.y + this.dir.y * t\n      };\n    }\n  }]);\n  return Ray;\n}();\n/**\n * The intersection between a ray and a collider.\n */\nvar RayIntersection = /*#__PURE__*/function () {\n  function RayIntersection(toi, normal, featureType, featureId) {\n    _classCallCheck(this, RayIntersection);\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    this.featureType = _feature__WEBPACK_IMPORTED_MODULE_0__.FeatureType.Unknown;\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    this.featureId = undefined;\n    this.toi = toi;\n    this.normal = normal;\n    if (featureId !== undefined) this.featureId = featureId;\n    if (featureType !== undefined) this.featureType = featureType;\n  }\n  _createClass(RayIntersection, null, [{\n    key: \"fromRaw\",\n    value: function fromRaw(raw) {\n      if (!raw) return null;\n      var result = new RayIntersection(raw.toi(), _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n      raw.free();\n      return result;\n    }\n  }]);\n  return RayIntersection;\n}();\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nvar RayColliderIntersection = /*#__PURE__*/function () {\n  function RayColliderIntersection(collider, toi, normal, featureType, featureId) {\n    _classCallCheck(this, RayColliderIntersection);\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    this.featureType = _feature__WEBPACK_IMPORTED_MODULE_0__.FeatureType.Unknown;\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    this.featureId = undefined;\n    this.collider = collider;\n    this.toi = toi;\n    this.normal = normal;\n    if (featureId !== undefined) this.featureId = featureId;\n    if (featureType !== undefined) this.featureType = featureType;\n  }\n  _createClass(RayColliderIntersection, null, [{\n    key: \"fromRaw\",\n    value: function fromRaw(colliderSet, raw) {\n      if (!raw) return null;\n      var result = new RayColliderIntersection(colliderSet.get(raw.colliderHandle()), raw.toi(), _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n      raw.free();\n      return result;\n    }\n  }]);\n  return RayColliderIntersection;\n}();\n/**\n * The time of impact between a ray and a collider.\n */\nvar RayColliderToi = /*#__PURE__*/function () {\n  function RayColliderToi(collider, toi) {\n    _classCallCheck(this, RayColliderToi);\n    this.collider = collider;\n    this.toi = toi;\n  }\n  _createClass(RayColliderToi, null, [{\n    key: \"fromRaw\",\n    value: function fromRaw(colliderSet, raw) {\n      if (!raw) return null;\n      var result = new RayColliderToi(colliderSet.get(raw.colliderHandle()), raw.toi());\n      raw.free();\n      return result;\n    }\n  }]);\n  return RayColliderToi;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/geometry/ray.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/shape.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/shape.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ball: () => (/* binding */ Ball),\n/* harmony export */   Capsule: () => (/* binding */ Capsule),\n/* harmony export */   ConvexPolygon: () => (/* binding */ ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* binding */ Cuboid),\n/* harmony export */   HalfSpace: () => (/* binding */ HalfSpace),\n/* harmony export */   Heightfield: () => (/* binding */ Heightfield),\n/* harmony export */   Polyline: () => (/* binding */ Polyline),\n/* harmony export */   RoundConvexPolygon: () => (/* binding */ RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* binding */ RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* binding */ RoundTriangle),\n/* harmony export */   Segment: () => (/* binding */ Segment),\n/* harmony export */   Shape: () => (/* binding */ Shape),\n/* harmony export */   ShapeType: () => (/* binding */ ShapeType),\n/* harmony export */   TriMesh: () => (/* binding */ TriMesh),\n/* harmony export */   Triangle: () => (/* binding */ Triangle)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _contact__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contact */ \"./node_modules/@dimforge/rapier2d/geometry/contact.js\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ \"./node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ray */ \"./node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _toi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toi */ \"./node_modules/@dimforge/rapier2d/geometry/toi.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__, _toi__WEBPACK_IMPORTED_MODULE_1__, _contact__WEBPACK_IMPORTED_MODULE_2__, _point__WEBPACK_IMPORTED_MODULE_3__, _ray__WEBPACK_IMPORTED_MODULE_4__, _raw__WEBPACK_IMPORTED_MODULE_5__]);\n([_math__WEBPACK_IMPORTED_MODULE_0__, _toi__WEBPACK_IMPORTED_MODULE_1__, _contact__WEBPACK_IMPORTED_MODULE_2__, _point__WEBPACK_IMPORTED_MODULE_3__, _ray__WEBPACK_IMPORTED_MODULE_4__, _raw__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\nvar Shape = /*#__PURE__*/function () {\n  function Shape() {\n    _classCallCheck(this, Shape);\n  }\n  _createClass(Shape, [{\n    key: \"castShape\",\n    value:\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exist that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    function castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi, stopAtPenetration) {\n      var rawPos1 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos1);\n      var rawRot1 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot1);\n      var rawVel1 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapeVel1);\n      var rawPos2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos2);\n      var rawRot2 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot2);\n      var rawVel2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapeVel2);\n      var rawShape1 = this.intoRaw();\n      var rawShape2 = shape2.intoRaw();\n      var result = _toi__WEBPACK_IMPORTED_MODULE_1__.ShapeTOI.fromRaw(null, rawShape1.castShape(rawPos1, rawRot1, rawVel1, rawShape2, rawPos2, rawRot2, rawVel2, maxToi, stopAtPenetration));\n      rawPos1.free();\n      rawRot1.free();\n      rawVel1.free();\n      rawPos2.free();\n      rawRot2.free();\n      rawVel2.free();\n      rawShape1.free();\n      rawShape2.free();\n      return result;\n    }\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they don’t.\n     */\n  }, {\n    key: \"intersectsShape\",\n    value: function intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n      var rawPos1 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos1);\n      var rawRot1 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot1);\n      var rawPos2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos2);\n      var rawRot2 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot2);\n      var rawShape1 = this.intoRaw();\n      var rawShape2 = shape2.intoRaw();\n      var result = rawShape1.intersectsShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2);\n      rawPos1.free();\n      rawRot1.free();\n      rawPos2.free();\n      rawRot2.free();\n      rawShape1.free();\n      rawShape2.free();\n      return result;\n    }\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n  }, {\n    key: \"contactShape\",\n    value: function contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n      var rawPos1 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos1);\n      var rawRot1 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot1);\n      var rawPos2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos2);\n      var rawRot2 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot2);\n      var rawShape1 = this.intoRaw();\n      var rawShape2 = shape2.intoRaw();\n      var result = _contact__WEBPACK_IMPORTED_MODULE_2__.ShapeContact.fromRaw(rawShape1.contactShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2, prediction));\n      rawPos1.free();\n      rawRot1.free();\n      rawPos2.free();\n      rawRot2.free();\n      rawShape1.free();\n      rawShape2.free();\n      return result;\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(shapePos, shapeRot, point) {\n      var rawPos = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos);\n      var rawRot = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot);\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n      var rawShape = this.intoRaw();\n      var result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n      rawPos.free();\n      rawRot.free();\n      rawPoint.free();\n      rawShape.free();\n      return result;\n    }\n  }, {\n    key: \"projectPoint\",\n    value: function projectPoint(shapePos, shapeRot, point, solid) {\n      var rawPos = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos);\n      var rawRot = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot);\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n      var rawShape = this.intoRaw();\n      var result = _point__WEBPACK_IMPORTED_MODULE_3__.PointProjection.fromRaw(rawShape.projectPoint(rawPos, rawRot, rawPoint, solid));\n      rawPos.free();\n      rawRot.free();\n      rawPoint.free();\n      rawShape.free();\n      return result;\n    }\n  }, {\n    key: \"intersectsRay\",\n    value: function intersectsRay(ray, shapePos, shapeRot, maxToi) {\n      var rawPos = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos);\n      var rawRot = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot);\n      var rawRayOrig = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.origin);\n      var rawRayDir = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.dir);\n      var rawShape = this.intoRaw();\n      var result = rawShape.intersectsRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi);\n      rawPos.free();\n      rawRot.free();\n      rawRayOrig.free();\n      rawRayDir.free();\n      rawShape.free();\n      return result;\n    }\n  }, {\n    key: \"castRay\",\n    value: function castRay(ray, shapePos, shapeRot, maxToi, solid) {\n      var rawPos = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos);\n      var rawRot = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot);\n      var rawRayOrig = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.origin);\n      var rawRayDir = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.dir);\n      var rawShape = this.intoRaw();\n      var result = rawShape.castRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid);\n      rawPos.free();\n      rawRot.free();\n      rawRayOrig.free();\n      rawRayDir.free();\n      rawShape.free();\n      return result;\n    }\n  }, {\n    key: \"castRayAndGetNormal\",\n    value: function castRayAndGetNormal(ray, shapePos, shapeRot, maxToi, solid) {\n      var rawPos = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos);\n      var rawRot = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot);\n      var rawRayOrig = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.origin);\n      var rawRayDir = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.dir);\n      var rawShape = this.intoRaw();\n      var result = _ray__WEBPACK_IMPORTED_MODULE_4__.RayIntersection.fromRaw(rawShape.castRayAndGetNormal(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid));\n      rawPos.free();\n      rawRot.free();\n      rawRayOrig.free();\n      rawRayDir.free();\n      rawShape.free();\n      return result;\n    }\n  }], [{\n    key: \"fromRaw\",\n    value:\n    /**\n     * instant mode without cache\n     */\n    function fromRaw(rawSet, handle) {\n      var rawType = rawSet.coShapeType(handle);\n      var extents;\n      var borderRadius;\n      var vs;\n      var indices;\n      var halfHeight;\n      var radius;\n      var normal;\n      switch (rawType) {\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.Ball:\n          return new Ball(rawSet.coRadius(handle));\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.Cuboid:\n          extents = rawSet.coHalfExtents(handle);\n          // #if DIM2\n          return new Cuboid(extents.x, extents.y);\n        // #endif\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.RoundCuboid:\n          extents = rawSet.coHalfExtents(handle);\n          borderRadius = rawSet.coRoundRadius(handle);\n          // #if DIM2\n          return new RoundCuboid(extents.x, extents.y, borderRadius);\n        // #endif\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.Capsule:\n          halfHeight = rawSet.coHalfHeight(handle);\n          radius = rawSet.coRadius(handle);\n          return new Capsule(halfHeight, radius);\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.Segment:\n          vs = rawSet.coVertices(handle);\n          // #if DIM2\n          return new Segment(_math__WEBPACK_IMPORTED_MODULE_0__.VectorOps[\"new\"](vs[0], vs[1]), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps[\"new\"](vs[2], vs[3]));\n        // #endif\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.Polyline:\n          vs = rawSet.coVertices(handle);\n          indices = rawSet.coIndices(handle);\n          return new Polyline(vs, indices);\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.Triangle:\n          vs = rawSet.coVertices(handle);\n          // #if DIM2\n          return new Triangle(_math__WEBPACK_IMPORTED_MODULE_0__.VectorOps[\"new\"](vs[0], vs[1]), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps[\"new\"](vs[2], vs[3]), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps[\"new\"](vs[4], vs[5]));\n        // #endif\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.RoundTriangle:\n          vs = rawSet.coVertices(handle);\n          borderRadius = rawSet.coRoundRadius(handle);\n          // #if DIM2\n          return new RoundTriangle(_math__WEBPACK_IMPORTED_MODULE_0__.VectorOps[\"new\"](vs[0], vs[1]), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps[\"new\"](vs[2], vs[3]), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps[\"new\"](vs[4], vs[5]), borderRadius);\n        // #endif\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.HalfSpace:\n          normal = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n          return new HalfSpace(normal);\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.TriMesh:\n          vs = rawSet.coVertices(handle);\n          indices = rawSet.coIndices(handle);\n          return new TriMesh(vs, indices);\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.HeightField:\n          var scale = rawSet.coHeightfieldScale(handle);\n          var heights = rawSet.coHeightfieldHeights(handle);\n          // #if DIM2\n          return new Heightfield(heights, scale);\n        // #endif\n        // #if DIM2\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.ConvexPolygon:\n          vs = rawSet.coVertices(handle);\n          return new ConvexPolygon(vs, false);\n        case _raw__WEBPACK_IMPORTED_MODULE_5__.RawShapeType.RoundConvexPolygon:\n          vs = rawSet.coVertices(handle);\n          borderRadius = rawSet.coRoundRadius(handle);\n          return new RoundConvexPolygon(vs, borderRadius, false);\n        // #endif\n        default:\n          throw new Error(\"unknown shape type: \" + rawType);\n      }\n    }\n  }]);\n  return Shape;\n}();\n// #if DIM2\n/**\n * An enumeration representing the type of a shape.\n */\nvar ShapeType;\n(function (ShapeType) {\n  ShapeType[ShapeType[\"Ball\"] = 0] = \"Ball\";\n  ShapeType[ShapeType[\"Cuboid\"] = 1] = \"Cuboid\";\n  ShapeType[ShapeType[\"Capsule\"] = 2] = \"Capsule\";\n  ShapeType[ShapeType[\"Segment\"] = 3] = \"Segment\";\n  ShapeType[ShapeType[\"Polyline\"] = 4] = \"Polyline\";\n  ShapeType[ShapeType[\"Triangle\"] = 5] = \"Triangle\";\n  ShapeType[ShapeType[\"TriMesh\"] = 6] = \"TriMesh\";\n  ShapeType[ShapeType[\"HeightField\"] = 7] = \"HeightField\";\n  // Compound = 8,\n  ShapeType[ShapeType[\"ConvexPolygon\"] = 9] = \"ConvexPolygon\";\n  ShapeType[ShapeType[\"RoundCuboid\"] = 10] = \"RoundCuboid\";\n  ShapeType[ShapeType[\"RoundTriangle\"] = 11] = \"RoundTriangle\";\n  ShapeType[ShapeType[\"RoundConvexPolygon\"] = 12] = \"RoundConvexPolygon\";\n  ShapeType[ShapeType[\"HalfSpace\"] = 13] = \"HalfSpace\";\n})(ShapeType || (ShapeType = {}));\n// #endif\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nvar Ball = /*#__PURE__*/function (_Shape) {\n  _inherits(Ball, _Shape);\n  /**\n   * Creates a new ball with the given radius.\n   * @param radius - The balls radius.\n   */\n  function Ball(radius) {\n    var _this;\n    _classCallCheck(this, Ball);\n    _this = _callSuper(this, Ball);\n    _this.type = ShapeType.Ball;\n    _this.radius = radius;\n    return _this;\n  }\n  _createClass(Ball, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      return _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.ball(this.radius);\n    }\n  }]);\n  return Ball;\n}(Shape);\nvar HalfSpace = /*#__PURE__*/function (_Shape2) {\n  _inherits(HalfSpace, _Shape2);\n  /**\n   * Creates a new halfspace delimited by an infinite plane.\n   *\n   * @param normal - The outward normal of the plane.\n   */\n  function HalfSpace(normal) {\n    var _this2;\n    _classCallCheck(this, HalfSpace);\n    _this2 = _callSuper(this, HalfSpace);\n    _this2.type = ShapeType.HalfSpace;\n    _this2.normal = normal;\n    return _this2;\n  }\n  _createClass(HalfSpace, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      var n = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.normal);\n      var result = _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.halfspace(n);\n      n.free();\n      return result;\n    }\n  }]);\n  return HalfSpace;\n}(Shape);\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nvar Cuboid = /*#__PURE__*/function (_Shape3) {\n  _inherits(Cuboid, _Shape3);\n  // #if DIM2\n  /**\n   * Creates a new 2D rectangle.\n   * @param hx - The half width of the rectangle.\n   * @param hy - The helf height of the rectangle.\n   */\n  function Cuboid(hx, hy) {\n    var _this3;\n    _classCallCheck(this, Cuboid);\n    _this3 = _callSuper(this, Cuboid);\n    _this3.type = ShapeType.Cuboid;\n    _this3.halfExtents = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps[\"new\"](hx, hy);\n    return _this3;\n  }\n  // #endif\n  _createClass(Cuboid, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      // #if DIM2\n      return _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.cuboid(this.halfExtents.x, this.halfExtents.y);\n      // #endif\n    }\n  }]);\n  return Cuboid;\n}(Shape);\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nvar RoundCuboid = /*#__PURE__*/function (_Shape4) {\n  _inherits(RoundCuboid, _Shape4);\n  // #if DIM2\n  /**\n   * Creates a new 2D rectangle.\n   * @param hx - The half width of the rectangle.\n   * @param hy - The helf height of the rectangle.\n   * @param borderRadius - The radius of the borders of this cuboid. This will\n   *   effectively increase the half-extents of the cuboid by this radius.\n   */\n  function RoundCuboid(hx, hy, borderRadius) {\n    var _this4;\n    _classCallCheck(this, RoundCuboid);\n    _this4 = _callSuper(this, RoundCuboid);\n    _this4.type = ShapeType.RoundCuboid;\n    _this4.halfExtents = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps[\"new\"](hx, hy);\n    _this4.borderRadius = borderRadius;\n    return _this4;\n  }\n  // #endif\n  _createClass(RoundCuboid, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      // #if DIM2\n      return _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.borderRadius);\n      // #endif\n    }\n  }]);\n  return RoundCuboid;\n}(Shape);\n/**\n * A shape that is a capsule.\n */\nvar Capsule = /*#__PURE__*/function (_Shape5) {\n  _inherits(Capsule, _Shape5);\n  /**\n   * Creates a new capsule with the given radius and half-height.\n   * @param halfHeight - The balls half-height along the `y` axis.\n   * @param radius - The balls radius.\n   */\n  function Capsule(halfHeight, radius) {\n    var _this5;\n    _classCallCheck(this, Capsule);\n    _this5 = _callSuper(this, Capsule);\n    _this5.type = ShapeType.Capsule;\n    _this5.halfHeight = halfHeight;\n    _this5.radius = radius;\n    return _this5;\n  }\n  _createClass(Capsule, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      return _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.capsule(this.halfHeight, this.radius);\n    }\n  }]);\n  return Capsule;\n}(Shape);\n/**\n * A shape that is a segment.\n */\nvar Segment = /*#__PURE__*/function (_Shape6) {\n  _inherits(Segment, _Shape6);\n  /**\n   * Creates a new segment shape.\n   * @param a - The first point of the segment.\n   * @param b - The second point of the segment.\n   */\n  function Segment(a, b) {\n    var _this6;\n    _classCallCheck(this, Segment);\n    _this6 = _callSuper(this, Segment);\n    _this6.type = ShapeType.Segment;\n    _this6.a = a;\n    _this6.b = b;\n    return _this6;\n  }\n  _createClass(Segment, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      var ra = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.a);\n      var rb = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.b);\n      var result = _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.segment(ra, rb);\n      ra.free();\n      rb.free();\n      return result;\n    }\n  }]);\n  return Segment;\n}(Shape);\n/**\n * A shape that is a segment.\n */\nvar Triangle = /*#__PURE__*/function (_Shape7) {\n  _inherits(Triangle, _Shape7);\n  /**\n   * Creates a new triangle shape.\n   *\n   * @param a - The first point of the triangle.\n   * @param b - The second point of the triangle.\n   * @param c - The third point of the triangle.\n   */\n  function Triangle(a, b, c) {\n    var _this7;\n    _classCallCheck(this, Triangle);\n    _this7 = _callSuper(this, Triangle);\n    _this7.type = ShapeType.Triangle;\n    _this7.a = a;\n    _this7.b = b;\n    _this7.c = c;\n    return _this7;\n  }\n  _createClass(Triangle, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      var ra = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.a);\n      var rb = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.b);\n      var rc = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.c);\n      var result = _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.triangle(ra, rb, rc);\n      ra.free();\n      rb.free();\n      rc.free();\n      return result;\n    }\n  }]);\n  return Triangle;\n}(Shape);\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nvar RoundTriangle = /*#__PURE__*/function (_Shape8) {\n  _inherits(RoundTriangle, _Shape8);\n  /**\n   * Creates a new triangle shape with round corners.\n   *\n   * @param a - The first point of the triangle.\n   * @param b - The second point of the triangle.\n   * @param c - The third point of the triangle.\n   * @param borderRadius - The radius of the borders of this triangle. In 3D,\n   *   this is also equal to half the thickness of the triangle.\n   */\n  function RoundTriangle(a, b, c, borderRadius) {\n    var _this8;\n    _classCallCheck(this, RoundTriangle);\n    _this8 = _callSuper(this, RoundTriangle);\n    _this8.type = ShapeType.RoundTriangle;\n    _this8.a = a;\n    _this8.b = b;\n    _this8.c = c;\n    _this8.borderRadius = borderRadius;\n    return _this8;\n  }\n  _createClass(RoundTriangle, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      var ra = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.a);\n      var rb = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.b);\n      var rc = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.c);\n      var result = _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n      ra.free();\n      rb.free();\n      rc.free();\n      return result;\n    }\n  }]);\n  return RoundTriangle;\n}(Shape);\n/**\n * A shape that is a triangle mesh.\n */\nvar Polyline = /*#__PURE__*/function (_Shape9) {\n  _inherits(Polyline, _Shape9);\n  /**\n   * Creates a new polyline shape.\n   *\n   * @param vertices - The coordinates of the polyline's vertices.\n   * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n   *    the vertices are assumed to form a line strip.\n   */\n  function Polyline(vertices, indices) {\n    var _this9;\n    _classCallCheck(this, Polyline);\n    _this9 = _callSuper(this, Polyline);\n    _this9.type = ShapeType.Polyline;\n    _this9.vertices = vertices;\n    _this9.indices = indices !== null && indices !== void 0 ? indices : new Uint32Array(0);\n    return _this9;\n  }\n  _createClass(Polyline, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      return _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.polyline(this.vertices, this.indices);\n    }\n  }]);\n  return Polyline;\n}(Shape);\n/**\n * A shape that is a triangle mesh.\n */\nvar TriMesh = /*#__PURE__*/function (_Shape10) {\n  _inherits(TriMesh, _Shape10);\n  /**\n   * Creates a new triangle mesh shape.\n   *\n   * @param vertices - The coordinates of the triangle mesh's vertices.\n   * @param indices - The indices of the triangle mesh's triangles.\n   */\n  function TriMesh(vertices, indices) {\n    var _this10;\n    _classCallCheck(this, TriMesh);\n    _this10 = _callSuper(this, TriMesh);\n    _this10.type = ShapeType.TriMesh;\n    _this10.vertices = vertices;\n    _this10.indices = indices;\n    return _this10;\n  }\n  _createClass(TriMesh, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      return _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.trimesh(this.vertices, this.indices);\n    }\n  }]);\n  return TriMesh;\n}(Shape);\n// #if DIM2\n/**\n * A shape that is a convex polygon.\n */\nvar ConvexPolygon = /*#__PURE__*/function (_Shape11) {\n  _inherits(ConvexPolygon, _Shape11);\n  /**\n   * Creates a new convex polygon shape.\n   *\n   * @param vertices - The coordinates of the convex polygon's vertices.\n   * @param skipConvexHullComputation - If set to `true`, the input points will\n   *   be assumed to form a convex polyline and no convex-hull computation will\n   *   be done automatically.\n   */\n  function ConvexPolygon(vertices, skipConvexHullComputation) {\n    var _this11;\n    _classCallCheck(this, ConvexPolygon);\n    _this11 = _callSuper(this, ConvexPolygon);\n    _this11.type = ShapeType.ConvexPolygon;\n    _this11.vertices = vertices;\n    _this11.skipConvexHullComputation = !!skipConvexHullComputation;\n    return _this11;\n  }\n  _createClass(ConvexPolygon, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      if (this.skipConvexHullComputation) {\n        return _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.convexPolyline(this.vertices);\n      } else {\n        return _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.convexHull(this.vertices);\n      }\n    }\n  }]);\n  return ConvexPolygon;\n}(Shape);\n/**\n * A shape that is a convex polygon.\n */\nvar RoundConvexPolygon = /*#__PURE__*/function (_Shape12) {\n  _inherits(RoundConvexPolygon, _Shape12);\n  /**\n   * Creates a new convex polygon shape.\n   *\n   * @param vertices - The coordinates of the convex polygon's vertices.\n   * @param borderRadius - The radius of the borders of this convex polygon.\n   * @param skipConvexHullComputation - If set to `true`, the input points will\n   *   be assumed to form a convex polyline and no convex-hull computation will\n   *   be done automatically.\n   */\n  function RoundConvexPolygon(vertices, borderRadius, skipConvexHullComputation) {\n    var _this12;\n    _classCallCheck(this, RoundConvexPolygon);\n    _this12 = _callSuper(this, RoundConvexPolygon);\n    _this12.type = ShapeType.RoundConvexPolygon;\n    _this12.vertices = vertices;\n    _this12.borderRadius = borderRadius;\n    _this12.skipConvexHullComputation = !!skipConvexHullComputation;\n    return _this12;\n  }\n  _createClass(RoundConvexPolygon, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      if (this.skipConvexHullComputation) {\n        return _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.roundConvexPolyline(this.vertices, this.borderRadius);\n      } else {\n        return _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.roundConvexHull(this.vertices, this.borderRadius);\n      }\n    }\n  }]);\n  return RoundConvexPolygon;\n}(Shape);\n/**\n * A shape that is a heightfield.\n */\nvar Heightfield = /*#__PURE__*/function (_Shape13) {\n  _inherits(Heightfield, _Shape13);\n  /**\n   * Creates a new heightfield shape.\n   *\n   * @param heights - The heights of the heightfield, along its local `y` axis.\n   * @param scale - The scale factor applied to the heightfield.\n   */\n  function Heightfield(heights, scale) {\n    var _this13;\n    _classCallCheck(this, Heightfield);\n    _this13 = _callSuper(this, Heightfield);\n    _this13.type = ShapeType.HeightField;\n    _this13.heights = heights;\n    _this13.scale = scale;\n    return _this13;\n  }\n  _createClass(Heightfield, [{\n    key: \"intoRaw\",\n    value: function intoRaw() {\n      var rawScale = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.scale);\n      var rawShape = _raw__WEBPACK_IMPORTED_MODULE_5__.RawShape.heightfield(this.heights, rawScale);\n      rawScale.free();\n      return rawShape;\n    }\n  }]);\n  return Heightfield;\n}(Shape);\n// #endif\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/geometry/shape.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/toi.js":
/*!*********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/toi.js ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShapeColliderTOI: () => (/* binding */ ShapeColliderTOI),\n/* harmony export */   ShapeTOI: () => (/* binding */ ShapeTOI)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n/**\n * The intersection between a ray and a collider.\n */\nvar ShapeTOI = /*#__PURE__*/function () {\n  function ShapeTOI(toi, witness1, witness2, normal1, normal2) {\n    _classCallCheck(this, ShapeTOI);\n    this.toi = toi;\n    this.witness1 = witness1;\n    this.witness2 = witness2;\n    this.normal1 = normal1;\n    this.normal2 = normal2;\n  }\n  _createClass(ShapeTOI, null, [{\n    key: \"fromRaw\",\n    value: function fromRaw(colliderSet, raw) {\n      if (!raw) return null;\n      var result = new ShapeTOI(raw.toi(), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness2()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal2()));\n      raw.free();\n      return result;\n    }\n  }]);\n  return ShapeTOI;\n}();\n/**\n * The intersection between a ray and a collider.\n */\nvar ShapeColliderTOI = /*#__PURE__*/function (_ShapeTOI) {\n  _inherits(ShapeColliderTOI, _ShapeTOI);\n  function ShapeColliderTOI(collider, toi, witness1, witness2, normal1, normal2) {\n    var _this;\n    _classCallCheck(this, ShapeColliderTOI);\n    _this = _callSuper(this, ShapeColliderTOI, [toi, witness1, witness2, normal1, normal2]);\n    _this.collider = collider;\n    return _this;\n  }\n  _createClass(ShapeColliderTOI, null, [{\n    key: \"fromRaw\",\n    value: function fromRaw(colliderSet, raw) {\n      if (!raw) return null;\n      var result = new ShapeColliderTOI(colliderSet.get(raw.colliderHandle()), raw.toi(), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness2()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal2()));\n      raw.free();\n      return result;\n    }\n  }]);\n  return ShapeColliderTOI;\n}(ShapeTOI);\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/geometry/toi.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/math.js":
/*!*************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/math.js ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RotationOps: () => (/* binding */ RotationOps),\n/* harmony export */   Vector2: () => (/* binding */ Vector2),\n/* harmony export */   VectorOps: () => (/* binding */ VectorOps)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A 2D vector.\n */\nvar Vector2 = /*#__PURE__*/_createClass(function Vector2(x, y) {\n  _classCallCheck(this, Vector2);\n  this.x = x;\n  this.y = y;\n});\nvar VectorOps = /*#__PURE__*/function () {\n  function VectorOps() {\n    _classCallCheck(this, VectorOps);\n  }\n  _createClass(VectorOps, null, [{\n    key: \"new\",\n    value: function _new(x, y) {\n      return new Vector2(x, y);\n    }\n  }, {\n    key: \"zeros\",\n    value: function zeros() {\n      return VectorOps[\"new\"](0.0, 0.0);\n    }\n    // FIXME: type ram: RawVector?\n  }, {\n    key: \"fromRaw\",\n    value: function fromRaw(raw) {\n      if (!raw) return null;\n      var res = VectorOps[\"new\"](raw.x, raw.y);\n      raw.free();\n      return res;\n    }\n  }, {\n    key: \"intoRaw\",\n    value: function intoRaw(v) {\n      return new _raw__WEBPACK_IMPORTED_MODULE_0__.RawVector(v.x, v.y);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(out, input) {\n      out.x = input.x;\n      out.y = input.y;\n    }\n  }]);\n  return VectorOps;\n}();\nvar RotationOps = /*#__PURE__*/function () {\n  function RotationOps() {\n    _classCallCheck(this, RotationOps);\n  }\n  _createClass(RotationOps, null, [{\n    key: \"identity\",\n    value: function identity() {\n      return 0.0;\n    }\n  }, {\n    key: \"fromRaw\",\n    value: function fromRaw(raw) {\n      if (!raw) return null;\n      var res = raw.angle;\n      raw.free();\n      return res;\n    }\n  }, {\n    key: \"intoRaw\",\n    value: function intoRaw(angle) {\n      return _raw__WEBPACK_IMPORTED_MODULE_0__.RawRotation.fromAngle(angle);\n    }\n  }]);\n  return RotationOps;\n}();\n// #endif\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/math.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DebugRenderBuffers: () => (/* binding */ DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* binding */ DebugRenderPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nvar DebugRenderBuffers = /*#__PURE__*/_createClass(function DebugRenderBuffers(vertices, colors) {\n  _classCallCheck(this, DebugRenderBuffers);\n  this.vertices = vertices;\n  this.colors = colors;\n});\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nvar DebugRenderPipeline = /*#__PURE__*/function () {\n  function DebugRenderPipeline(raw) {\n    _classCallCheck(this, DebugRenderPipeline);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawDebugRenderPipeline();\n  }\n  /**\n   * Release the WASM memory occupied by this serialization pipeline.\n   */\n  _createClass(DebugRenderPipeline, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n      this.vertices = undefined;\n      this.colors = undefined;\n    }\n  }, {\n    key: \"render\",\n    value: function render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n      this.raw.render(bodies.raw, colliders.raw, impulse_joints.raw, multibody_joints.raw, narrow_phase.raw);\n      this.vertices = this.raw.vertices();\n      this.colors = this.raw.colors();\n    }\n  }]);\n  return DebugRenderPipeline;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/event_queue.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/event_queue.js ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveEvents: () => (/* binding */ ActiveEvents),\n/* harmony export */   EventQueue: () => (/* binding */ EventQueue),\n/* harmony export */   TempContactForceEvent: () => (/* binding */ TempContactForceEvent)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__]);\n([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n/**\n * Flags indicating what events are enabled for colliders.\n */\nvar ActiveEvents;\n(function (ActiveEvents) {\n  ActiveEvents[ActiveEvents[\"NONE\"] = 0] = \"NONE\";\n  /**\n   * Enable collision events.\n   */\n  ActiveEvents[ActiveEvents[\"COLLISION_EVENTS\"] = 1] = \"COLLISION_EVENTS\";\n  /**\n   * Enable contact force events.\n   */\n  ActiveEvents[ActiveEvents[\"CONTACT_FORCE_EVENTS\"] = 2] = \"CONTACT_FORCE_EVENTS\";\n})(ActiveEvents || (ActiveEvents = {}));\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nvar TempContactForceEvent = /*#__PURE__*/function () {\n  function TempContactForceEvent() {\n    _classCallCheck(this, TempContactForceEvent);\n  }\n  _createClass(TempContactForceEvent, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n    }\n    /**\n     * The first collider involved in the contact.\n     */\n  }, {\n    key: \"collider1\",\n    value: function collider1() {\n      return this.raw.collider1();\n    }\n    /**\n     * The second collider involved in the contact.\n     */\n  }, {\n    key: \"collider2\",\n    value: function collider2() {\n      return this.raw.collider2();\n    }\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n  }, {\n    key: \"totalForce\",\n    value: function totalForce() {\n      return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.raw.total_force());\n    }\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n  }, {\n    key: \"totalForceMagnitude\",\n    value: function totalForceMagnitude() {\n      return this.raw.total_force_magnitude();\n    }\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n  }, {\n    key: \"maxForceDirection\",\n    value: function maxForceDirection() {\n      return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n  }, {\n    key: \"maxForceMagnitude\",\n    value: function maxForceMagnitude() {\n      return this.raw.max_force_magnitude();\n    }\n  }]);\n  return TempContactForceEvent;\n}();\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nvar EventQueue = /*#__PURE__*/function () {\n  /**\n   * Creates a new event collector.\n   *\n   * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n   * be automatically drained before each `world.step(collector)`. If false, the collector will\n   * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n   * RAM if no drain is performed.\n   */\n  function EventQueue(autoDrain, raw) {\n    _classCallCheck(this, EventQueue);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_1__.RawEventQueue(autoDrain);\n  }\n  /**\n   * Release the WASM memory occupied by this event-queue.\n   */\n  _createClass(EventQueue, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n    }\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n  }, {\n    key: \"drainCollisionEvents\",\n    value: function drainCollisionEvents(f) {\n      this.raw.drainCollisionEvents(f);\n    }\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n  }, {\n    key: \"drainContactForceEvents\",\n    value: function drainContactForceEvents(f) {\n      var event = new TempContactForceEvent();\n      this.raw.drainContactForceEvents(function (raw) {\n        event.raw = raw;\n        f(event);\n        event.free();\n      });\n    }\n    /**\n     * Removes all events contained by this collector\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.raw.clear();\n    }\n  }]);\n  return EventQueue;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/pipeline/event_queue.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/index.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveEvents: () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.ActiveEvents),\n/* harmony export */   ActiveHooks: () => (/* reexport safe */ _physics_hooks__WEBPACK_IMPORTED_MODULE_4__.ActiveHooks),\n/* harmony export */   DebugRenderBuffers: () => (/* reexport safe */ _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__.DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* reexport safe */ _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__.DebugRenderPipeline),\n/* harmony export */   EventQueue: () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.EventQueue),\n/* harmony export */   PhysicsPipeline: () => (/* reexport safe */ _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__.PhysicsPipeline),\n/* harmony export */   QueryFilterFlags: () => (/* reexport safe */ _query_pipeline__WEBPACK_IMPORTED_MODULE_6__.QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* reexport safe */ _query_pipeline__WEBPACK_IMPORTED_MODULE_6__.QueryPipeline),\n/* harmony export */   SerializationPipeline: () => (/* reexport safe */ _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__.SerializationPipeline),\n/* harmony export */   SolverFlags: () => (/* reexport safe */ _physics_hooks__WEBPACK_IMPORTED_MODULE_4__.SolverFlags),\n/* harmony export */   TempContactForceEvent: () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.TempContactForceEvent),\n/* harmony export */   World: () => (/* reexport safe */ _world__WEBPACK_IMPORTED_MODULE_0__.World)\n/* harmony export */ });\n/* harmony import */ var _world__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./world */ \"./node_modules/@dimforge/rapier2d/pipeline/world.js\");\n/* harmony import */ var _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./physics_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js\");\n/* harmony import */ var _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serialization_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js\");\n/* harmony import */ var _event_queue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./event_queue */ \"./node_modules/@dimforge/rapier2d/pipeline/event_queue.js\");\n/* harmony import */ var _physics_hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./physics_hooks */ \"./node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js\");\n/* harmony import */ var _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./debug_render_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js\");\n/* harmony import */ var _query_pipeline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./query_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_world__WEBPACK_IMPORTED_MODULE_0__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__, _event_queue__WEBPACK_IMPORTED_MODULE_3__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__, _query_pipeline__WEBPACK_IMPORTED_MODULE_6__]);\n([_world__WEBPACK_IMPORTED_MODULE_0__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__, _event_queue__WEBPACK_IMPORTED_MODULE_3__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__, _query_pipeline__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/pipeline/index.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveHooks: () => (/* binding */ ActiveHooks),\n/* harmony export */   SolverFlags: () => (/* binding */ SolverFlags)\n/* harmony export */ });\nvar ActiveHooks;\n(function (ActiveHooks) {\n  ActiveHooks[ActiveHooks[\"NONE\"] = 0] = \"NONE\";\n  ActiveHooks[ActiveHooks[\"FILTER_CONTACT_PAIRS\"] = 1] = \"FILTER_CONTACT_PAIRS\";\n  ActiveHooks[ActiveHooks[\"FILTER_INTERSECTION_PAIRS\"] = 2] = \"FILTER_INTERSECTION_PAIRS\";\n  // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n})(ActiveHooks || (ActiveHooks = {}));\nvar SolverFlags;\n(function (SolverFlags) {\n  SolverFlags[SolverFlags[\"EMPTY\"] = 0] = \"EMPTY\";\n  SolverFlags[SolverFlags[\"COMPUTE_IMPULSE\"] = 1] = \"COMPUTE_IMPULSE\";\n})(SolverFlags || (SolverFlags = {}));\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsPipeline: () => (/* binding */ PhysicsPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar PhysicsPipeline = /*#__PURE__*/function () {\n  function PhysicsPipeline(raw) {\n    _classCallCheck(this, PhysicsPipeline);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawPhysicsPipeline();\n  }\n  _createClass(PhysicsPipeline, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n    }\n  }, {\n    key: \"step\",\n    value: function step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints, ccdSolver, eventQueue, hooks) {\n      var rawG = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(gravity);\n      if (!!eventQueue) {\n        this.raw.stepWithEvents(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw, eventQueue.raw, hooks, !!hooks ? hooks.filterContactPair : null, !!hooks ? hooks.filterIntersectionPair : null);\n      } else {\n        this.raw.step(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw);\n      }\n      rawG.free();\n    }\n  }]);\n  return PhysicsPipeline;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js":
/*!********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryFilterFlags: () => (/* binding */ QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* binding */ QueryPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/toi.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _geometry__WEBPACK_IMPORTED_MODULE_4__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _geometry__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nvar QueryFilterFlags;\n(function (QueryFilterFlags) {\n  /**\n   * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n   */\n  QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_FIXED\"] = 1] = \"EXCLUDE_FIXED\";\n  /**\n   * Exclude from the query any collider attached to a dynamic rigid-body.\n   */\n  QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_KINEMATIC\"] = 2] = \"EXCLUDE_KINEMATIC\";\n  /**\n   * Exclude from the query any collider attached to a kinematic rigid-body.\n   */\n  QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_DYNAMIC\"] = 4] = \"EXCLUDE_DYNAMIC\";\n  /**\n   * Exclude from the query any collider that is a sensor.\n   */\n  QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SENSORS\"] = 8] = \"EXCLUDE_SENSORS\";\n  /**\n   * Exclude from the query any collider that is not a sensor.\n   */\n  QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SOLIDS\"] = 16] = \"EXCLUDE_SOLIDS\";\n  /**\n   * Excludes all colliders not attached to a dynamic rigid-body.\n   */\n  QueryFilterFlags[QueryFilterFlags[\"ONLY_DYNAMIC\"] = 3] = \"ONLY_DYNAMIC\";\n  /**\n   * Excludes all colliders not attached to a kinematic rigid-body.\n   */\n  QueryFilterFlags[QueryFilterFlags[\"ONLY_KINEMATIC\"] = 5] = \"ONLY_KINEMATIC\";\n  /**\n   * Exclude all colliders attached to a non-fixed rigid-body\n   * (this will not exclude colliders not attached to any rigid-body).\n   */\n  QueryFilterFlags[QueryFilterFlags[\"ONLY_FIXED\"] = 6] = \"ONLY_FIXED\";\n})(QueryFilterFlags || (QueryFilterFlags = {}));\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nvar QueryPipeline = /*#__PURE__*/function () {\n  function QueryPipeline(raw) {\n    _classCallCheck(this, QueryPipeline);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawQueryPipeline();\n  }\n  /**\n   * Release the WASM memory occupied by this query pipeline.\n   */\n  _createClass(QueryPipeline, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n    }\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param bodies - The set of rigid-bodies taking part in this pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n  }, {\n    key: \"update\",\n    value: function update(bodies, colliders) {\n      this.raw.update(bodies.raw, colliders.raw);\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n  }, {\n    key: \"castRay\",\n    value: function castRay(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      var rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n      var rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n      var result = _geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderToi.fromRaw(colliders, this.raw.castRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n      rawOrig.free();\n      rawDir.free();\n      return result;\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n  }, {\n    key: \"castRayAndGetNormal\",\n    value: function castRayAndGetNormal(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      var rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n      var rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n      var result = _geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderIntersection.fromRaw(colliders, this.raw.castRayAndGetNormal(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n      rawOrig.free();\n      rawDir.free();\n      return result;\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n  }, {\n    key: \"intersectionsWithRay\",\n    value: function intersectionsWithRay(bodies, colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      var rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n      var rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n      var rawCallback = function rawCallback(rawInter) {\n        return callback(_geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderIntersection.fromRaw(colliders, rawInter));\n      };\n      this.raw.intersectionsWithRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, rawCallback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n      rawOrig.free();\n      rawDir.free();\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n  }, {\n    key: \"intersectionWithShape\",\n    value: function intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      var rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n      var rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n      var rawShape = shape.intoRaw();\n      var result = this.raw.intersectionWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n      rawPos.free();\n      rawRot.free();\n      rawShape.free();\n      return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n  }, {\n    key: \"projectPoint\",\n    value: function projectPoint(bodies, colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n      var result = _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection.fromRaw(colliders, this.raw.projectPoint(bodies.raw, colliders.raw, rawPoint, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n      rawPoint.free();\n      return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n  }, {\n    key: \"projectPointAndGetFeature\",\n    value: function projectPointAndGetFeature(bodies, colliders, point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n      var result = _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection.fromRaw(colliders, this.raw.projectPointAndGetFeature(bodies.raw, colliders.raw, rawPoint, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n      rawPoint.free();\n      return result;\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n  }, {\n    key: \"intersectionsWithPoint\",\n    value: function intersectionsWithPoint(bodies, colliders, point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      var rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n      this.raw.intersectionsWithPoint(bodies.raw, colliders.raw, rawPoint, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n      rawPoint.free();\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n  }, {\n    key: \"castShape\",\n    value: function castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      var rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n      var rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n      var rawVel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapeVel);\n      var rawShape = shape.intoRaw();\n      var result = _geometry__WEBPACK_IMPORTED_MODULE_4__.ShapeColliderTOI.fromRaw(colliders, this.raw.castShape(bodies.raw, colliders.raw, rawPos, rawRot, rawVel, rawShape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n      rawPos.free();\n      rawRot.free();\n      rawVel.free();\n      rawShape.free();\n      return result;\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n  }, {\n    key: \"intersectionsWithShape\",\n    value: function intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      var rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n      var rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n      var rawShape = shape.intoRaw();\n      this.raw.intersectionsWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n      rawPos.free();\n      rawRot.free();\n      rawShape.free();\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n  }, {\n    key: \"collidersWithAabbIntersectingAabb\",\n    value: function collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n      var rawCenter = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(aabbCenter);\n      var rawHalfExtents = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(aabbHalfExtents);\n      this.raw.collidersWithAabbIntersectingAabb(rawCenter, rawHalfExtents, callback);\n      rawCenter.free();\n      rawHalfExtents.free();\n    }\n  }]);\n  return QueryPipeline;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SerializationPipeline: () => (/* binding */ SerializationPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _world__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./world */ \"./node_modules/@dimforge/rapier2d/pipeline/world.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _world__WEBPACK_IMPORTED_MODULE_2__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _world__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nvar SerializationPipeline = /*#__PURE__*/function () {\n  function SerializationPipeline(raw) {\n    _classCallCheck(this, SerializationPipeline);\n    this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawSerializationPipeline();\n  }\n  /**\n   * Release the WASM memory occupied by this serialization pipeline.\n   */\n  _createClass(SerializationPipeline, [{\n    key: \"free\",\n    value: function free() {\n      if (!!this.raw) {\n        this.raw.free();\n      }\n      this.raw = undefined;\n    }\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n  }, {\n    key: \"serializeAll\",\n    value: function serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints) {\n      var rawGra = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(gravity);\n      var res = this.raw.serializeAll(rawGra, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n      rawGra.free();\n      return res;\n    }\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n  }, {\n    key: \"deserializeAll\",\n    value: function deserializeAll(data) {\n      return _world__WEBPACK_IMPORTED_MODULE_2__.World.fromRaw(this.raw.deserializeAll(data));\n    }\n  }]);\n  return SerializationPipeline;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/world.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/world.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   World: () => (/* binding */ World)\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/broad_phase.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/narrow_phase.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/collider_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/island_manager.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./physics_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js\");\n/* harmony import */ var _query_pipeline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./query_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js\");\n/* harmony import */ var _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./serialization_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js\");\n/* harmony import */ var _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./debug_render_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js\");\n/* harmony import */ var _control__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../control */ \"./node_modules/@dimforge/rapier2d/control/character_controller.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_dynamics__WEBPACK_IMPORTED_MODULE_0__, _dynamics__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _dynamics__WEBPACK_IMPORTED_MODULE_4__, _geometry__WEBPACK_IMPORTED_MODULE_5__, _dynamics__WEBPACK_IMPORTED_MODULE_6__, _dynamics__WEBPACK_IMPORTED_MODULE_7__, _dynamics__WEBPACK_IMPORTED_MODULE_8__, _query_pipeline__WEBPACK_IMPORTED_MODULE_9__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__, _control__WEBPACK_IMPORTED_MODULE_13__, _math__WEBPACK_IMPORTED_MODULE_14__]);\n([_dynamics__WEBPACK_IMPORTED_MODULE_0__, _dynamics__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _dynamics__WEBPACK_IMPORTED_MODULE_4__, _geometry__WEBPACK_IMPORTED_MODULE_5__, _dynamics__WEBPACK_IMPORTED_MODULE_6__, _dynamics__WEBPACK_IMPORTED_MODULE_7__, _dynamics__WEBPACK_IMPORTED_MODULE_8__, _query_pipeline__WEBPACK_IMPORTED_MODULE_9__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__, _control__WEBPACK_IMPORTED_MODULE_13__, _math__WEBPACK_IMPORTED_MODULE_14__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\n\n\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nvar World = /*#__PURE__*/function () {\n  function World(gravity, rawIntegrationParameters, rawIslands, rawBroadPhase, rawNarrowPhase, rawBodies, rawColliders, rawImpulseJoints, rawMultibodyJoints, rawCCDSolver, rawQueryPipeline, rawPhysicsPipeline, rawSerializationPipeline, rawDebugRenderPipeline) {\n    _classCallCheck(this, World);\n    this.gravity = gravity;\n    this.integrationParameters = new _dynamics__WEBPACK_IMPORTED_MODULE_0__.IntegrationParameters(rawIntegrationParameters);\n    this.islands = new _dynamics__WEBPACK_IMPORTED_MODULE_1__.IslandManager(rawIslands);\n    this.broadPhase = new _geometry__WEBPACK_IMPORTED_MODULE_2__.BroadPhase(rawBroadPhase);\n    this.narrowPhase = new _geometry__WEBPACK_IMPORTED_MODULE_3__.NarrowPhase(rawNarrowPhase);\n    this.bodies = new _dynamics__WEBPACK_IMPORTED_MODULE_4__.RigidBodySet(rawBodies);\n    this.colliders = new _geometry__WEBPACK_IMPORTED_MODULE_5__.ColliderSet(rawColliders);\n    this.impulseJoints = new _dynamics__WEBPACK_IMPORTED_MODULE_6__.ImpulseJointSet(rawImpulseJoints);\n    this.multibodyJoints = new _dynamics__WEBPACK_IMPORTED_MODULE_7__.MultibodyJointSet(rawMultibodyJoints);\n    this.ccdSolver = new _dynamics__WEBPACK_IMPORTED_MODULE_8__.CCDSolver(rawCCDSolver);\n    this.queryPipeline = new _query_pipeline__WEBPACK_IMPORTED_MODULE_9__.QueryPipeline(rawQueryPipeline);\n    this.physicsPipeline = new _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__.PhysicsPipeline(rawPhysicsPipeline);\n    this.serializationPipeline = new _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__.SerializationPipeline(rawSerializationPipeline);\n    this.debugRenderPipeline = new _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__.DebugRenderPipeline(rawDebugRenderPipeline);\n    this.characterControllers = new Set();\n    this.impulseJoints.finalizeDeserialization(this.bodies);\n    this.bodies.finalizeDeserialization(this.colliders);\n    this.colliders.finalizeDeserialization(this.bodies);\n  }\n  /**\n   * Release the WASM memory occupied by this physics world.\n   *\n   * All the fields of this physics world will be freed as well,\n   * so there is no need to call their `.free()` methods individually.\n   */\n  _createClass(World, [{\n    key: \"free\",\n    value: function free() {\n      this.integrationParameters.free();\n      this.islands.free();\n      this.broadPhase.free();\n      this.narrowPhase.free();\n      this.bodies.free();\n      this.colliders.free();\n      this.impulseJoints.free();\n      this.multibodyJoints.free();\n      this.ccdSolver.free();\n      this.queryPipeline.free();\n      this.physicsPipeline.free();\n      this.serializationPipeline.free();\n      this.debugRenderPipeline.free();\n      this.characterControllers.forEach(function (controller) {\n        return controller.free();\n      });\n      this.integrationParameters = undefined;\n      this.islands = undefined;\n      this.broadPhase = undefined;\n      this.narrowPhase = undefined;\n      this.bodies = undefined;\n      this.colliders = undefined;\n      this.ccdSolver = undefined;\n      this.impulseJoints = undefined;\n      this.multibodyJoints = undefined;\n      this.queryPipeline = undefined;\n      this.physicsPipeline = undefined;\n      this.serializationPipeline = undefined;\n      this.debugRenderPipeline = undefined;\n      this.characterControllers = undefined;\n    }\n  }, {\n    key: \"takeSnapshot\",\n    value:\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    function takeSnapshot() {\n      return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);\n    }\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n  }, {\n    key: \"debugRender\",\n    value:\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    function debugRender() {\n      this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase);\n      return new _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__.DebugRenderBuffers(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);\n    }\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n  }, {\n    key: \"step\",\n    value: function step(eventQueue, hooks) {\n      this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, eventQueue, hooks);\n      this.queryPipeline.update(this.bodies, this.colliders);\n    }\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n  }, {\n    key: \"propagateModifiedBodyPositionsToColliders\",\n    value: function propagateModifiedBodyPositionsToColliders() {\n      this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);\n    }\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n  }, {\n    key: \"updateSceneQueries\",\n    value: function updateSceneQueries() {\n      this.propagateModifiedBodyPositionsToColliders();\n      this.queryPipeline.update(this.bodies, this.colliders);\n    }\n    /**\n     * The current simulation timestep.\n     */\n  }, {\n    key: \"timestep\",\n    get: function get() {\n      return this.integrationParameters.dt;\n    }\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */,\n    set: function set(dt) {\n      this.integrationParameters.dt = dt;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n  }, {\n    key: \"numSolverIterations\",\n    get: function get() {\n      return this.integrationParameters.numSolverIterations;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of solver iterations.\n     */,\n    set: function set(niter) {\n      this.integrationParameters.numSolverIterations = niter;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n  }, {\n    key: \"numAdditionalFrictionIterations\",\n    get: function get() {\n      return this.integrationParameters.numAdditionalFrictionIterations;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of additional friction iterations.\n     */,\n    set: function set(niter) {\n      this.integrationParameters.numAdditionalFrictionIterations = niter;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n  }, {\n    key: \"numInternalPgsIterations\",\n    get: function get() {\n      return this.integrationParameters.numInternalPgsIterations;\n    }\n    /**\n     * Sets the Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     *\n     * Increasing this parameter will improve stability of the simulation. It will have a lesser effect than\n     * increasing `numSolverIterations` but is also less computationally expensive.\n     *\n     * @param niter - The new number of internal PGS iterations.\n     */,\n    set: function set(niter) {\n      this.integrationParameters.numInternalPgsIterations = niter;\n    }\n    /// Configures the integration parameters to match the old PGS solver\n    /// from Rapier JS version <= 0.11.\n    ///\n    /// This solver was slightly faster than the new one but resulted\n    /// in less stable joints and worse convergence rates.\n    ///\n    /// This should only be used for comparison purpose or if you are\n    /// experiencing problems with the new solver.\n    ///\n    /// NOTE: this does not affect any `RigidBody.additional_solver_iterations` that will\n    ///       still create solver iterations based on the new \"small-steps\" PGS solver.\n  }, {\n    key: \"switchToStandardPgsSolver\",\n    value: function switchToStandardPgsSolver() {\n      this.integrationParameters.switchToStandardPgsSolver();\n    }\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n  }, {\n    key: \"switchToSmallStepsPgsSolver\",\n    value: function switchToSmallStepsPgsSolver() {\n      this.integrationParameters.switchToSmallStepsPgsSolver();\n    }\n    /**\n     * Creates a new rigid-body from the given rigid-body descriptor.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n  }, {\n    key: \"createRigidBody\",\n    value: function createRigidBody(body) {\n      return this.bodies.createRigidBody(this.colliders, body);\n    }\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the character’s chape and its environment.\n     */\n  }, {\n    key: \"createCharacterController\",\n    value: function createCharacterController(offset) {\n      var controller = new _control__WEBPACK_IMPORTED_MODULE_13__.KinematicCharacterController(offset, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);\n      this.characterControllers.add(controller);\n      return controller;\n    }\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n  }, {\n    key: \"removeCharacterController\",\n    value: function removeCharacterController(controller) {\n      this.characterControllers[\"delete\"](controller);\n      controller.free();\n    }\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n  }, {\n    key: \"createCollider\",\n    value: function createCollider(desc, parent) {\n      var parentHandle = parent ? parent.handle : undefined;\n      return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n  }, {\n    key: \"createImpulseJoint\",\n    value: function createImpulseJoint(params, parent1, parent2, wakeUp) {\n      return this.impulseJoints.createJoint(this.bodies, params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n  }, {\n    key: \"createMultibodyJoint\",\n    value: function createMultibodyJoint(params, parent1, parent2, wakeUp) {\n      return this.multibodyJoints.createJoint(params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n  }, {\n    key: \"getRigidBody\",\n    value: function getRigidBody(handle) {\n      return this.bodies.get(handle);\n    }\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n  }, {\n    key: \"getCollider\",\n    value: function getCollider(handle) {\n      return this.colliders.get(handle);\n    }\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n  }, {\n    key: \"getImpulseJoint\",\n    value: function getImpulseJoint(handle) {\n      return this.impulseJoints.get(handle);\n    }\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n  }, {\n    key: \"getMultibodyJoint\",\n    value: function getMultibodyJoint(handle) {\n      return this.multibodyJoints.get(handle);\n    }\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n  }, {\n    key: \"removeRigidBody\",\n    value: function removeRigidBody(body) {\n      if (this.bodies) {\n        this.bodies.remove(body.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);\n      }\n    }\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n  }, {\n    key: \"removeCollider\",\n    value: function removeCollider(collider, wakeUp) {\n      if (this.colliders) {\n        this.colliders.remove(collider.handle, this.islands, this.bodies, wakeUp);\n      }\n    }\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n  }, {\n    key: \"removeImpulseJoint\",\n    value: function removeImpulseJoint(joint, wakeUp) {\n      if (this.impulseJoints) {\n        this.impulseJoints.remove(joint.handle, wakeUp);\n      }\n    }\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n  }, {\n    key: \"removeMultibodyJoint\",\n    value: function removeMultibodyJoint(joint, wakeUp) {\n      if (this.impulseJoints) {\n        this.multibodyJoints.remove(joint.handle, wakeUp);\n      }\n    }\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n  }, {\n    key: \"forEachCollider\",\n    value: function forEachCollider(f) {\n      this.colliders.forEach(f);\n    }\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n  }, {\n    key: \"forEachRigidBody\",\n    value: function forEachRigidBody(f) {\n      this.bodies.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n  }, {\n    key: \"forEachActiveRigidBody\",\n    value: function forEachActiveRigidBody(f) {\n      this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n  }, {\n    key: \"castRay\",\n    value: function castRay(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      return this.queryPipeline.castRay(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n  }, {\n    key: \"castRayAndGetNormal\",\n    value: function castRayAndGetNormal(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n  }, {\n    key: \"intersectionsWithRay\",\n    value: function intersectionsWithRay(ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n  }, {\n    key: \"intersectionWithShape\",\n    value: function intersectionWithShape(shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      var handle = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n      return handle != null ? this.colliders.get(handle) : null;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n  }, {\n    key: \"projectPoint\",\n    value: function projectPoint(point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      return this.queryPipeline.projectPoint(this.bodies, this.colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n  }, {\n    key: \"projectPointAndGetFeature\",\n    value: function projectPointAndGetFeature(point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, point, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n  }, {\n    key: \"intersectionsWithPoint\",\n    value: function intersectionsWithPoint(point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, point, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n  }, {\n    key: \"castShape\",\n    value: function castShape(shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      return this.queryPipeline.castShape(this.bodies, this.colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n  }, {\n    key: \"intersectionsWithShape\",\n    value: function intersectionsWithShape(shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n      this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n  }, {\n    key: \"collidersWithAabbIntersectingAabb\",\n    value: function collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n      this.queryPipeline.collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, this.colliders.castClosure(callback));\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n  }, {\n    key: \"contactPairsWith\",\n    value: function contactPairsWith(collider1, f) {\n      this.narrowPhase.contactPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n  }, {\n    key: \"intersectionPairsWith\",\n    value: function intersectionPairsWith(collider1, f) {\n      this.narrowPhase.intersectionPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n  }, {\n    key: \"contactPair\",\n    value: function contactPair(collider1, collider2, f) {\n      this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n  }, {\n    key: \"intersectionPair\",\n    value: function intersectionPair(collider1, collider2) {\n      return this.narrowPhase.intersectionPair(collider1.handle, collider2.handle);\n    }\n  }], [{\n    key: \"fromRaw\",\n    value: function fromRaw(raw) {\n      if (!raw) return null;\n      return new World(_math__WEBPACK_IMPORTED_MODULE_14__.VectorOps.fromRaw(raw.takeGravity()), raw.takeIntegrationParameters(), raw.takeIslandManager(), raw.takeBroadPhase(), raw.takeNarrowPhase(), raw.takeBodies(), raw.takeColliders(), raw.takeImpulseJoints(), raw.takeMultibodyJoints());\n    }\n  }, {\n    key: \"restoreSnapshot\",\n    value: function restoreSnapshot(data) {\n      var deser = new _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__.SerializationPipeline();\n      return deser.deserializeAll(data);\n    }\n  }]);\n  return World;\n}();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/pipeline/world.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/rapier.js":
/*!***************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/rapier.js ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveCollisionTypes),\n/* harmony export */   ActiveEvents: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents),\n/* harmony export */   ActiveHooks: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveHooks),\n/* harmony export */   Ball: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Ball),\n/* harmony export */   BroadPhase: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.BroadPhase),\n/* harmony export */   CCDSolver: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CCDSolver),\n/* harmony export */   Capsule: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Capsule),\n/* harmony export */   CharacterCollision: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CharacterCollision),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CoefficientCombineRule),\n/* harmony export */   Collider: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Collider),\n/* harmony export */   ColliderDesc: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ColliderDesc),\n/* harmony export */   ColliderSet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ColliderSet),\n/* harmony export */   ConvexPolygon: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Cuboid),\n/* harmony export */   DebugRenderBuffers: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.DebugRenderPipeline),\n/* harmony export */   EventQueue: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.EventQueue),\n/* harmony export */   FeatureType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FeatureType),\n/* harmony export */   FixedImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FixedImpulseJoint),\n/* harmony export */   FixedMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FixedMultibodyJoint),\n/* harmony export */   HalfSpace: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.HalfSpace),\n/* harmony export */   Heightfield: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Heightfield),\n/* harmony export */   ImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ImpulseJoint),\n/* harmony export */   ImpulseJointSet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ImpulseJointSet),\n/* harmony export */   IntegrationParameters: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.IntegrationParameters),\n/* harmony export */   IslandManager: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.IslandManager),\n/* harmony export */   JointAxesMask: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.JointAxesMask),\n/* harmony export */   JointData: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.JointData),\n/* harmony export */   JointType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.JointType),\n/* harmony export */   KinematicCharacterController: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.KinematicCharacterController),\n/* harmony export */   MassPropsMode: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MassPropsMode),\n/* harmony export */   MotorModel: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MotorModel),\n/* harmony export */   MultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MultibodyJoint),\n/* harmony export */   MultibodyJointSet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MultibodyJointSet),\n/* harmony export */   NarrowPhase: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.NarrowPhase),\n/* harmony export */   PhysicsPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PhysicsPipeline),\n/* harmony export */   PointColliderProjection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PointProjection),\n/* harmony export */   Polyline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Polyline),\n/* harmony export */   PrismaticImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PrismaticImpulseJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PrismaticMultibodyJoint),\n/* harmony export */   QueryFilterFlags: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.QueryPipeline),\n/* harmony export */   Ray: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Ray),\n/* harmony export */   RayColliderIntersection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayColliderIntersection),\n/* harmony export */   RayColliderToi: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayColliderToi),\n/* harmony export */   RayIntersection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayIntersection),\n/* harmony export */   RevoluteImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RevoluteImpulseJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RevoluteMultibodyJoint),\n/* harmony export */   RigidBody: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc),\n/* harmony export */   RigidBodySet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodySet),\n/* harmony export */   RigidBodyType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodyType),\n/* harmony export */   RopeImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RopeImpulseJoint),\n/* harmony export */   RotationOps: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RotationOps),\n/* harmony export */   RoundConvexPolygon: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundTriangle),\n/* harmony export */   Segment: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Segment),\n/* harmony export */   SerializationPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SerializationPipeline),\n/* harmony export */   Shape: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Shape),\n/* harmony export */   ShapeColliderTOI: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeColliderTOI),\n/* harmony export */   ShapeContact: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeContact),\n/* harmony export */   ShapeTOI: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeTOI),\n/* harmony export */   ShapeType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeType),\n/* harmony export */   SolverFlags: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SolverFlags),\n/* harmony export */   SpringImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SpringImpulseJoint),\n/* harmony export */   TempContactForceEvent: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TempContactForceEvent),\n/* harmony export */   TempContactManifold: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TempContactManifold),\n/* harmony export */   TriMesh: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TriMesh),\n/* harmony export */   Triangle: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Triangle),\n/* harmony export */   UnitImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.UnitImpulseJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.UnitMultibodyJoint),\n/* harmony export */   Vector2: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Vector2),\n/* harmony export */   VectorOps: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.VectorOps),\n/* harmony export */   World: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.World),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   version: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.version)\n/* harmony export */ });\n/* harmony import */ var _exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exports */ \"./node_modules/@dimforge/rapier2d/exports.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_exports__WEBPACK_IMPORTED_MODULE_0__]);\n_exports__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_exports__WEBPACK_IMPORTED_MODULE_0__);\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/rapier.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/rapier_wasm2d.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/rapier_wasm2d.js ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RawBroadPhase: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawBroadPhase),\n/* harmony export */   RawCCDSolver: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawCCDSolver),\n/* harmony export */   RawCharacterCollision: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawCharacterCollision),\n/* harmony export */   RawColliderSet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawColliderSet),\n/* harmony export */   RawContactForceEvent: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawContactForceEvent),\n/* harmony export */   RawContactManifold: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawContactManifold),\n/* harmony export */   RawContactPair: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawContactPair),\n/* harmony export */   RawDebugRenderPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawDebugRenderPipeline),\n/* harmony export */   RawDeserializedWorld: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawDeserializedWorld),\n/* harmony export */   RawEventQueue: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawEventQueue),\n/* harmony export */   RawFeatureType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawFeatureType),\n/* harmony export */   RawGenericJoint: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawGenericJoint),\n/* harmony export */   RawImpulseJointSet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawImpulseJointSet),\n/* harmony export */   RawIntegrationParameters: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawIntegrationParameters),\n/* harmony export */   RawIslandManager: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawIslandManager),\n/* harmony export */   RawJointAxis: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis),\n/* harmony export */   RawJointType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawJointType),\n/* harmony export */   RawKinematicCharacterController: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawKinematicCharacterController),\n/* harmony export */   RawMotorModel: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawMotorModel),\n/* harmony export */   RawMultibodyJointSet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawMultibodyJointSet),\n/* harmony export */   RawNarrowPhase: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawNarrowPhase),\n/* harmony export */   RawPhysicsPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawPhysicsPipeline),\n/* harmony export */   RawPointColliderProjection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawPointColliderProjection),\n/* harmony export */   RawPointProjection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawPointProjection),\n/* harmony export */   RawQueryPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawQueryPipeline),\n/* harmony export */   RawRayColliderIntersection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRayColliderIntersection),\n/* harmony export */   RawRayColliderToi: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRayColliderToi),\n/* harmony export */   RawRayIntersection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRayIntersection),\n/* harmony export */   RawRigidBodySet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodySet),\n/* harmony export */   RawRigidBodyType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodyType),\n/* harmony export */   RawRotation: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRotation),\n/* harmony export */   RawSerializationPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawSerializationPipeline),\n/* harmony export */   RawShape: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShape),\n/* harmony export */   RawShapeColliderTOI: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShapeColliderTOI),\n/* harmony export */   RawShapeContact: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShapeContact),\n/* harmony export */   RawShapeTOI: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShapeTOI),\n/* harmony export */   RawShapeType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShapeType),\n/* harmony export */   RawVector: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawVector),\n/* harmony export */   __wbg_bind_60a9a80cada2f33c: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_bind_60a9a80cada2f33c),\n/* harmony export */   __wbg_buffer_085ec1f694018c4f: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_buffer_085ec1f694018c4f),\n/* harmony export */   __wbg_call_01734de55d61e11d: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_01734de55d61e11d),\n/* harmony export */   __wbg_call_4c92f6aec1e1d6e6: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_4c92f6aec1e1d6e6),\n/* harmony export */   __wbg_call_776890ca77946e2f: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_776890ca77946e2f),\n/* harmony export */   __wbg_length_72e2208bbc0efc61: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_72e2208bbc0efc61),\n/* harmony export */   __wbg_length_d7327c75a759af37: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_d7327c75a759af37),\n/* harmony export */   __wbg_new_8125e318e6245eed: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_8125e318e6245eed),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_69193e31c844b792: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_69193e31c844b792),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_6da8e527659b86aa: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_6da8e527659b86aa),\n/* harmony export */   __wbg_newwithlength_68d29ab115d0099c: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithlength_68d29ab115d0099c),\n/* harmony export */   __wbg_rawcontactforceevent_new: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_rawcontactforceevent_new),\n/* harmony export */   __wbg_rawraycolliderintersection_new: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_rawraycolliderintersection_new),\n/* harmony export */   __wbg_set_5cf90238115182c3: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_5cf90238115182c3),\n/* harmony export */   __wbg_set_6146c51d49a2c0df: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_6146c51d49a2c0df),\n/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm),\n/* harmony export */   __wbindgen_boolean_get: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_boolean_get),\n/* harmony export */   __wbindgen_is_function: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_function),\n/* harmony export */   __wbindgen_memory: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_memory),\n/* harmony export */   __wbindgen_number_get: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_number_get),\n/* harmony export */   __wbindgen_number_new: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_number_new),\n/* harmony export */   __wbindgen_object_drop_ref: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_object_drop_ref),\n/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_throw),\n/* harmony export */   version: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.version)\n/* harmony export */ });\n/* harmony import */ var _rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rapier_wasm2d_bg.wasm */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.wasm\");\n/* harmony import */ var _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rapier_wasm2d_bg.js */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__]);\n_rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n(0,_rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm)(_rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/rapier_wasm2d.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RawBroadPhase: () => (/* binding */ RawBroadPhase),\n/* harmony export */   RawCCDSolver: () => (/* binding */ RawCCDSolver),\n/* harmony export */   RawCharacterCollision: () => (/* binding */ RawCharacterCollision),\n/* harmony export */   RawColliderSet: () => (/* binding */ RawColliderSet),\n/* harmony export */   RawContactForceEvent: () => (/* binding */ RawContactForceEvent),\n/* harmony export */   RawContactManifold: () => (/* binding */ RawContactManifold),\n/* harmony export */   RawContactPair: () => (/* binding */ RawContactPair),\n/* harmony export */   RawDebugRenderPipeline: () => (/* binding */ RawDebugRenderPipeline),\n/* harmony export */   RawDeserializedWorld: () => (/* binding */ RawDeserializedWorld),\n/* harmony export */   RawEventQueue: () => (/* binding */ RawEventQueue),\n/* harmony export */   RawFeatureType: () => (/* binding */ RawFeatureType),\n/* harmony export */   RawGenericJoint: () => (/* binding */ RawGenericJoint),\n/* harmony export */   RawImpulseJointSet: () => (/* binding */ RawImpulseJointSet),\n/* harmony export */   RawIntegrationParameters: () => (/* binding */ RawIntegrationParameters),\n/* harmony export */   RawIslandManager: () => (/* binding */ RawIslandManager),\n/* harmony export */   RawJointAxis: () => (/* binding */ RawJointAxis),\n/* harmony export */   RawJointType: () => (/* binding */ RawJointType),\n/* harmony export */   RawKinematicCharacterController: () => (/* binding */ RawKinematicCharacterController),\n/* harmony export */   RawMotorModel: () => (/* binding */ RawMotorModel),\n/* harmony export */   RawMultibodyJointSet: () => (/* binding */ RawMultibodyJointSet),\n/* harmony export */   RawNarrowPhase: () => (/* binding */ RawNarrowPhase),\n/* harmony export */   RawPhysicsPipeline: () => (/* binding */ RawPhysicsPipeline),\n/* harmony export */   RawPointColliderProjection: () => (/* binding */ RawPointColliderProjection),\n/* harmony export */   RawPointProjection: () => (/* binding */ RawPointProjection),\n/* harmony export */   RawQueryPipeline: () => (/* binding */ RawQueryPipeline),\n/* harmony export */   RawRayColliderIntersection: () => (/* binding */ RawRayColliderIntersection),\n/* harmony export */   RawRayColliderToi: () => (/* binding */ RawRayColliderToi),\n/* harmony export */   RawRayIntersection: () => (/* binding */ RawRayIntersection),\n/* harmony export */   RawRigidBodySet: () => (/* binding */ RawRigidBodySet),\n/* harmony export */   RawRigidBodyType: () => (/* binding */ RawRigidBodyType),\n/* harmony export */   RawRotation: () => (/* binding */ RawRotation),\n/* harmony export */   RawSerializationPipeline: () => (/* binding */ RawSerializationPipeline),\n/* harmony export */   RawShape: () => (/* binding */ RawShape),\n/* harmony export */   RawShapeColliderTOI: () => (/* binding */ RawShapeColliderTOI),\n/* harmony export */   RawShapeContact: () => (/* binding */ RawShapeContact),\n/* harmony export */   RawShapeTOI: () => (/* binding */ RawShapeTOI),\n/* harmony export */   RawShapeType: () => (/* binding */ RawShapeType),\n/* harmony export */   RawVector: () => (/* binding */ RawVector),\n/* harmony export */   __wbg_bind_60a9a80cada2f33c: () => (/* binding */ __wbg_bind_60a9a80cada2f33c),\n/* harmony export */   __wbg_buffer_085ec1f694018c4f: () => (/* binding */ __wbg_buffer_085ec1f694018c4f),\n/* harmony export */   __wbg_call_01734de55d61e11d: () => (/* binding */ __wbg_call_01734de55d61e11d),\n/* harmony export */   __wbg_call_4c92f6aec1e1d6e6: () => (/* binding */ __wbg_call_4c92f6aec1e1d6e6),\n/* harmony export */   __wbg_call_776890ca77946e2f: () => (/* binding */ __wbg_call_776890ca77946e2f),\n/* harmony export */   __wbg_length_72e2208bbc0efc61: () => (/* binding */ __wbg_length_72e2208bbc0efc61),\n/* harmony export */   __wbg_length_d7327c75a759af37: () => (/* binding */ __wbg_length_d7327c75a759af37),\n/* harmony export */   __wbg_new_8125e318e6245eed: () => (/* binding */ __wbg_new_8125e318e6245eed),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_69193e31c844b792: () => (/* binding */ __wbg_newwithbyteoffsetandlength_69193e31c844b792),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_6da8e527659b86aa: () => (/* binding */ __wbg_newwithbyteoffsetandlength_6da8e527659b86aa),\n/* harmony export */   __wbg_newwithlength_68d29ab115d0099c: () => (/* binding */ __wbg_newwithlength_68d29ab115d0099c),\n/* harmony export */   __wbg_rawcontactforceevent_new: () => (/* binding */ __wbg_rawcontactforceevent_new),\n/* harmony export */   __wbg_rawraycolliderintersection_new: () => (/* binding */ __wbg_rawraycolliderintersection_new),\n/* harmony export */   __wbg_set_5cf90238115182c3: () => (/* binding */ __wbg_set_5cf90238115182c3),\n/* harmony export */   __wbg_set_6146c51d49a2c0df: () => (/* binding */ __wbg_set_6146c51d49a2c0df),\n/* harmony export */   __wbg_set_wasm: () => (/* binding */ __wbg_set_wasm),\n/* harmony export */   __wbindgen_boolean_get: () => (/* binding */ __wbindgen_boolean_get),\n/* harmony export */   __wbindgen_is_function: () => (/* binding */ __wbindgen_is_function),\n/* harmony export */   __wbindgen_memory: () => (/* binding */ __wbindgen_memory),\n/* harmony export */   __wbindgen_number_get: () => (/* binding */ __wbindgen_number_get),\n/* harmony export */   __wbindgen_number_new: () => (/* binding */ __wbindgen_number_new),\n/* harmony export */   __wbindgen_object_drop_ref: () => (/* binding */ __wbindgen_object_drop_ref),\n/* harmony export */   __wbindgen_throw: () => (/* binding */ __wbindgen_throw),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar wasm;\nfunction __wbg_set_wasm(val) {\n  wasm = val;\n}\nvar heap = new Array(128).fill(undefined);\nheap.push(undefined, null, true, false);\nvar heap_next = heap.length;\nfunction addHeapObject(obj) {\n  if (heap_next === heap.length) heap.push(heap.length + 1);\n  var idx = heap_next;\n  heap_next = heap[idx];\n  heap[idx] = obj;\n  return idx;\n}\nfunction getObject(idx) {\n  return heap[idx];\n}\nfunction dropObject(idx) {\n  if (idx < 132) return;\n  heap[idx] = heap_next;\n  heap_next = idx;\n}\nfunction takeObject(idx) {\n  var ret = getObject(idx);\n  dropObject(idx);\n  return ret;\n}\nfunction isLikeNone(x) {\n  return x === undefined || x === null;\n}\nvar cachedFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n  if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n    cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n  }\n  return cachedFloat64Memory0;\n}\nvar cachedInt32Memory0 = null;\nfunction getInt32Memory0() {\n  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n  }\n  return cachedInt32Memory0;\n}\nvar lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\nvar cachedTextDecoder = new lTextDecoder('utf-8', {\n  ignoreBOM: true,\n  fatal: true\n});\ncachedTextDecoder.decode();\nvar cachedUint8Memory0 = null;\nfunction getUint8Memory0() {\n  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachedUint8Memory0;\n}\nfunction getStringFromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @returns {string}\n*/\nfunction version() {\n  var deferred1_0;\n  var deferred1_1;\n  try {\n    var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n    wasm.version(retptr);\n    var r0 = getInt32Memory0()[retptr / 4 + 0];\n    var r1 = getInt32Memory0()[retptr / 4 + 1];\n    deferred1_0 = r0;\n    deferred1_1 = r1;\n    return getStringFromWasm0(r0, r1);\n  } finally {\n    wasm.__wbindgen_add_to_stack_pointer(16);\n    wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n  }\n}\nfunction _assertClass(instance, klass) {\n  if (!(instance instanceof klass)) {\n    throw new Error(\"expected instance of \".concat(klass.name));\n  }\n  return instance.ptr;\n}\nvar cachedFloat32Memory0 = null;\nfunction getFloat32Memory0() {\n  if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n    cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n  }\n  return cachedFloat32Memory0;\n}\nvar stack_pointer = 128;\nfunction addBorrowedObject(obj) {\n  if (stack_pointer == 1) throw new Error('out of js stack');\n  heap[--stack_pointer] = obj;\n  return stack_pointer;\n}\nfunction getArrayF32FromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\nvar cachedUint32Memory0 = null;\nfunction getUint32Memory0() {\n  if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n    cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n  }\n  return cachedUint32Memory0;\n}\nfunction getArrayU32FromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\nvar WASM_VECTOR_LEN = 0;\nfunction passArrayF32ToWasm0(arg, malloc) {\n  var ptr = malloc(arg.length * 4, 4) >>> 0;\n  getFloat32Memory0().set(arg, ptr / 4);\n  WASM_VECTOR_LEN = arg.length;\n  return ptr;\n}\nfunction passArray32ToWasm0(arg, malloc) {\n  var ptr = malloc(arg.length * 4, 4) >>> 0;\n  getUint32Memory0().set(arg, ptr / 4);\n  WASM_VECTOR_LEN = arg.length;\n  return ptr;\n}\nfunction handleError(f, args) {\n  try {\n    return f.apply(this, args);\n  } catch (e) {\n    wasm.__wbindgen_exn_store(addHeapObject(e));\n  }\n}\n/**\n*/\nvar RawFeatureType = Object.freeze({\n  Vertex: 0,\n  \"0\": \"Vertex\",\n  Face: 1,\n  \"1\": \"Face\",\n  Unknown: 2,\n  \"2\": \"Unknown\"\n});\n/**\n*/\nvar RawRigidBodyType = Object.freeze({\n  Dynamic: 0,\n  \"0\": \"Dynamic\",\n  Fixed: 1,\n  \"1\": \"Fixed\",\n  KinematicPositionBased: 2,\n  \"2\": \"KinematicPositionBased\",\n  KinematicVelocityBased: 3,\n  \"3\": \"KinematicVelocityBased\"\n});\n/**\n*/\nvar RawJointType = Object.freeze({\n  Revolute: 0,\n  \"0\": \"Revolute\",\n  Fixed: 1,\n  \"1\": \"Fixed\",\n  Prismatic: 2,\n  \"2\": \"Prismatic\",\n  Rope: 3,\n  \"3\": \"Rope\",\n  Spring: 4,\n  \"4\": \"Spring\",\n  Generic: 5,\n  \"5\": \"Generic\"\n});\n/**\n*/\nvar RawShapeType = Object.freeze({\n  Ball: 0,\n  \"0\": \"Ball\",\n  Cuboid: 1,\n  \"1\": \"Cuboid\",\n  Capsule: 2,\n  \"2\": \"Capsule\",\n  Segment: 3,\n  \"3\": \"Segment\",\n  Polyline: 4,\n  \"4\": \"Polyline\",\n  Triangle: 5,\n  \"5\": \"Triangle\",\n  TriMesh: 6,\n  \"6\": \"TriMesh\",\n  HeightField: 7,\n  \"7\": \"HeightField\",\n  Compound: 8,\n  \"8\": \"Compound\",\n  ConvexPolygon: 9,\n  \"9\": \"ConvexPolygon\",\n  RoundCuboid: 10,\n  \"10\": \"RoundCuboid\",\n  RoundTriangle: 11,\n  \"11\": \"RoundTriangle\",\n  RoundConvexPolygon: 12,\n  \"12\": \"RoundConvexPolygon\",\n  HalfSpace: 13,\n  \"13\": \"HalfSpace\"\n});\n/**\n*/\nvar RawMotorModel = Object.freeze({\n  AccelerationBased: 0,\n  \"0\": \"AccelerationBased\",\n  ForceBased: 1,\n  \"1\": \"ForceBased\"\n});\n/**\n*/\nvar RawJointAxis = Object.freeze({\n  X: 0,\n  \"0\": \"X\",\n  Y: 1,\n  \"1\": \"Y\",\n  AngX: 2,\n  \"2\": \"AngX\"\n});\n/**\n*/\nvar RawBroadPhase = /*#__PURE__*/function () {\n  /**\n  */\n  function RawBroadPhase() {\n    _classCallCheck(this, RawBroadPhase);\n    var ret = wasm.rawbroadphase_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  _createClass(RawBroadPhase, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawbroadphase_free(ptr);\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawBroadPhase.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawBroadPhase;\n}();\n/**\n*/\nvar RawCCDSolver = /*#__PURE__*/function () {\n  /**\n  */\n  function RawCCDSolver() {\n    _classCallCheck(this, RawCCDSolver);\n    var ret = wasm.rawccdsolver_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  _createClass(RawCCDSolver, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawccdsolver_free(ptr);\n    }\n  }]);\n  return RawCCDSolver;\n}();\n/**\n*/\nvar RawCharacterCollision = /*#__PURE__*/function () {\n  /**\n  */\n  function RawCharacterCollision() {\n    _classCallCheck(this, RawCharacterCollision);\n    var ret = wasm.rawcharactercollision_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @returns {number}\n  */\n  _createClass(RawCharacterCollision, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawcharactercollision_free(ptr);\n    }\n  }, {\n    key: \"handle\",\n    value: function handle() {\n      var ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"translationDeltaApplied\",\n    value: function translationDeltaApplied() {\n      var ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"translationDeltaRemaining\",\n    value: function translationDeltaRemaining() {\n      var ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"toi\",\n    value: function toi() {\n      var ret = wasm.rawcharactercollision_toi(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"worldWitness1\",\n    value: function worldWitness1() {\n      var ret = wasm.rawcharactercollision_worldWitness1(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"worldWitness2\",\n    value: function worldWitness2() {\n      var ret = wasm.rawcharactercollision_worldWitness2(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"worldNormal1\",\n    value: function worldNormal1() {\n      var ret = wasm.rawcharactercollision_worldNormal1(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"worldNormal2\",\n    value: function worldNormal2() {\n      var ret = wasm.rawcharactercollision_worldNormal2(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n  }]);\n  return RawCharacterCollision;\n}();\n/**\n*/\nvar RawColliderSet = /*#__PURE__*/function () {\n  /**\n  */\n  function RawColliderSet() {\n    _classCallCheck(this, RawColliderSet);\n    var ret = wasm.rawcolliderset_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @returns {number}\n  */\n  _createClass(RawColliderSet, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"coTranslation\",\n    value: function coTranslation(handle) {\n      var ret = wasm.rawcolliderset_coTranslation(this.__wbg_ptr, handle);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n  }, {\n    key: \"coRotation\",\n    value: function coRotation(handle) {\n      var ret = wasm.rawcolliderset_coRotation(this.__wbg_ptr, handle);\n      return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n  }, {\n    key: \"coSetTranslation\",\n    value: function coSetTranslation(handle, x, y) {\n      wasm.rawcolliderset_coSetTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n  }, {\n    key: \"coSetTranslationWrtParent\",\n    value: function coSetTranslationWrtParent(handle, x, y) {\n      wasm.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * Sets the rotation angle of this collider.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} angle\n    */\n  }, {\n    key: \"coSetRotation\",\n    value: function coSetRotation(handle, angle) {\n      wasm.rawcolliderset_coSetRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} angle\n    */\n  }, {\n    key: \"coSetRotationWrtParent\",\n    value: function coSetRotationWrtParent(handle, angle) {\n      wasm.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"coIsSensor\",\n    value: function coIsSensor(handle) {\n      var ret = wasm.rawcolliderset_coIsSensor(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {RawShapeType}\n    */\n  }, {\n    key: \"coShapeType\",\n    value: function coShapeType(handle) {\n      var ret = wasm.rawcolliderset_coShapeType(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n  }, {\n    key: \"coHalfspaceNormal\",\n    value: function coHalfspaceNormal(handle) {\n      var ret = wasm.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, handle);\n      return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n  }, {\n    key: \"coHalfExtents\",\n    value: function coHalfExtents(handle) {\n      var ret = wasm.rawcolliderset_coHalfExtents(this.__wbg_ptr, handle);\n      return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * Set the half-extents of this collider if it has a cuboid shape.\n    * @param {number} handle\n    * @param {RawVector} newHalfExtents\n    */\n  }, {\n    key: \"coSetHalfExtents\",\n    value: function coSetHalfExtents(handle, newHalfExtents) {\n      _assertClass(newHalfExtents, RawVector);\n      wasm.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, handle, newHalfExtents.__wbg_ptr);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"coRadius\",\n    value: function coRadius(handle) {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawcolliderset_coRadius(retptr, this.__wbg_ptr, handle);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getFloat32Memory0()[retptr / 4 + 1];\n        return r0 === 0 ? undefined : r1;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n    /**\n    * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newRadius\n    */\n  }, {\n    key: \"coSetRadius\",\n    value: function coSetRadius(handle, newRadius) {\n      wasm.rawcolliderset_coSetRadius(this.__wbg_ptr, handle, newRadius);\n    }\n    /**\n    * The half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"coHalfHeight\",\n    value: function coHalfHeight(handle) {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawcolliderset_coHalfHeight(retptr, this.__wbg_ptr, handle);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getFloat32Memory0()[retptr / 4 + 1];\n        return r0 === 0 ? undefined : r1;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n    /**\n    * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newHalfheight\n    */\n  }, {\n    key: \"coSetHalfHeight\",\n    value: function coSetHalfHeight(handle, newHalfheight) {\n      wasm.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, handle, newHalfheight);\n    }\n    /**\n    * The radius of the round edges of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"coRoundRadius\",\n    value: function coRoundRadius(handle) {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawcolliderset_coRoundRadius(retptr, this.__wbg_ptr, handle);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getFloat32Memory0()[retptr / 4 + 1];\n        return r0 === 0 ? undefined : r1;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n    /**\n    * Set the radius of the round edges of this collider.\n    * @param {number} handle\n    * @param {number} newBorderRadius\n    */\n  }, {\n    key: \"coSetRoundRadius\",\n    value: function coSetRoundRadius(handle, newBorderRadius) {\n      wasm.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, handle, newBorderRadius);\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n  }, {\n    key: \"coVertices\",\n    value: function coVertices(handle) {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawcolliderset_coVertices(retptr, this.__wbg_ptr, handle);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1;\n        if (r0 !== 0) {\n          v1 = getArrayF32FromWasm0(r0, r1).slice();\n          wasm.__wbindgen_free(r0, r1 * 4, 4);\n        }\n        return v1;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n  }, {\n    key: \"coIndices\",\n    value: function coIndices(handle) {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawcolliderset_coIndices(retptr, this.__wbg_ptr, handle);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1;\n        if (r0 !== 0) {\n          v1 = getArrayU32FromWasm0(r0, r1).slice();\n          wasm.__wbindgen_free(r0, r1 * 4, 4);\n        }\n        return v1;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n  }, {\n    key: \"coHeightfieldHeights\",\n    value: function coHeightfieldHeights(handle) {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawcolliderset_coHeightfieldHeights(retptr, this.__wbg_ptr, handle);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1;\n        if (r0 !== 0) {\n          v1 = getArrayF32FromWasm0(r0, r1).slice();\n          wasm.__wbindgen_free(r0, r1 * 4, 4);\n        }\n        return v1;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n  }, {\n    key: \"coHeightfieldScale\",\n    value: function coHeightfieldScale(handle) {\n      var ret = wasm.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, handle);\n      return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"coParent\",\n    value: function coParent(handle) {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawcolliderset_coParent(retptr, this.__wbg_ptr, handle);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r2 = getFloat64Memory0()[retptr / 8 + 1];\n        return r0 === 0 ? undefined : r2;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n  }, {\n    key: \"coSetEnabled\",\n    value: function coSetEnabled(handle, enabled) {\n      wasm.rawcolliderset_coSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"coIsEnabled\",\n    value: function coIsEnabled(handle) {\n      var ret = wasm.rawcolliderset_coIsEnabled(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coFriction\",\n    value: function coFriction(handle) {\n      var ret = wasm.rawcolliderset_coFriction(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The restitution coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coRestitution\",\n    value: function coRestitution(handle) {\n      var ret = wasm.rawcolliderset_coRestitution(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coDensity\",\n    value: function coDensity(handle) {\n      var ret = wasm.rawcolliderset_coDensity(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The mass of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coMass\",\n    value: function coMass(handle) {\n      var ret = wasm.rawcolliderset_coMass(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The volume of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coVolume\",\n    value: function coVolume(handle) {\n      var ret = wasm.rawcolliderset_coVolume(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coCollisionGroups\",\n    value: function coCollisionGroups(handle) {\n      var ret = wasm.rawcolliderset_coCollisionGroups(this.__wbg_ptr, handle);\n      return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coSolverGroups\",\n    value: function coSolverGroups(handle) {\n      var ret = wasm.rawcolliderset_coSolverGroups(this.__wbg_ptr, handle);\n      return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coActiveHooks\",\n    value: function coActiveHooks(handle) {\n      var ret = wasm.rawcolliderset_coActiveHooks(this.__wbg_ptr, handle);\n      return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coActiveCollisionTypes\",\n    value: function coActiveCollisionTypes(handle) {\n      var ret = wasm.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coActiveEvents\",\n    value: function coActiveEvents(handle) {\n      var ret = wasm.rawcolliderset_coActiveEvents(this.__wbg_ptr, handle);\n      return ret >>> 0;\n    }\n    /**\n    * The total force magnitude beyond which a contact force event can be emitted.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coContactForceEventThreshold\",\n    value: function coContactForceEventThreshold(handle) {\n      var ret = wasm.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n  }, {\n    key: \"coContainsPoint\",\n    value: function coContainsPoint(handle, point) {\n      _assertClass(point, RawVector);\n      var ret = wasm.rawcolliderset_coContainsPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n      return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} colliderVel\n    * @param {RawShape} shape2\n    * @param {RawVector} shape2Pos\n    * @param {RawRotation} shape2Rot\n    * @param {RawVector} shape2Vel\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n  }, {\n    key: \"coCastShape\",\n    value: function coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi, stop_at_penetration) {\n      _assertClass(colliderVel, RawVector);\n      _assertClass(shape2, RawShape);\n      _assertClass(shape2Pos, RawVector);\n      _assertClass(shape2Rot, RawRotation);\n      _assertClass(shape2Vel, RawVector);\n      var ret = wasm.rawcolliderset_coCastShape(this.__wbg_ptr, handle, colliderVel.__wbg_ptr, shape2.__wbg_ptr, shape2Pos.__wbg_ptr, shape2Rot.__wbg_ptr, shape2Vel.__wbg_ptr, maxToi, stop_at_penetration);\n      return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} collider1Vel\n    * @param {number} collider2handle\n    * @param {RawVector} collider2Vel\n    * @param {number} max_toi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n  }, {\n    key: \"coCastCollider\",\n    value: function coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, max_toi, stop_at_penetration) {\n      _assertClass(collider1Vel, RawVector);\n      _assertClass(collider2Vel, RawVector);\n      var ret = wasm.rawcolliderset_coCastCollider(this.__wbg_ptr, handle, collider1Vel.__wbg_ptr, collider2handle, collider2Vel.__wbg_ptr, max_toi, stop_at_penetration);\n      return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n  }, {\n    key: \"coIntersectsShape\",\n    value: function coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n      _assertClass(shape2, RawShape);\n      _assertClass(shapePos2, RawVector);\n      _assertClass(shapeRot2, RawRotation);\n      var ret = wasm.rawcolliderset_coIntersectsShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n      return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n  }, {\n    key: \"coContactShape\",\n    value: function coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n      _assertClass(shape2, RawShape);\n      _assertClass(shapePos2, RawVector);\n      _assertClass(shapeRot2, RawRotation);\n      var ret = wasm.rawcolliderset_coContactShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n      return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} collider2handle\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n  }, {\n    key: \"coContactCollider\",\n    value: function coContactCollider(handle, collider2handle, prediction) {\n      var ret = wasm.rawcolliderset_coContactCollider(this.__wbg_ptr, handle, collider2handle, prediction);\n      return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n  }, {\n    key: \"coProjectPoint\",\n    value: function coProjectPoint(handle, point, solid) {\n      _assertClass(point, RawVector);\n      var ret = wasm.rawcolliderset_coProjectPoint(this.__wbg_ptr, handle, point.__wbg_ptr, solid);\n      return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n  }, {\n    key: \"coIntersectsRay\",\n    value: function coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n      _assertClass(rayOrig, RawVector);\n      _assertClass(rayDir, RawVector);\n      var ret = wasm.rawcolliderset_coIntersectsRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n      return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n  }, {\n    key: \"coCastRay\",\n    value: function coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n      _assertClass(rayOrig, RawVector);\n      _assertClass(rayDir, RawVector);\n      var ret = wasm.rawcolliderset_coCastRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n      return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n  }, {\n    key: \"coCastRayAndGetNormal\",\n    value: function coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n      _assertClass(rayOrig, RawVector);\n      _assertClass(rayDir, RawVector);\n      var ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n      return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n  }, {\n    key: \"coSetSensor\",\n    value: function coSetSensor(handle, is_sensor) {\n      wasm.rawcolliderset_coSetSensor(this.__wbg_ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n  }, {\n    key: \"coSetRestitution\",\n    value: function coSetRestitution(handle, restitution) {\n      wasm.rawcolliderset_coSetRestitution(this.__wbg_ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n  }, {\n    key: \"coSetFriction\",\n    value: function coSetFriction(handle, friction) {\n      wasm.rawcolliderset_coSetFriction(this.__wbg_ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coFrictionCombineRule\",\n    value: function coFrictionCombineRule(handle) {\n      var ret = wasm.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, handle);\n      return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n  }, {\n    key: \"coSetFrictionCombineRule\",\n    value: function coSetFrictionCombineRule(handle, rule) {\n      wasm.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"coRestitutionCombineRule\",\n    value: function coRestitutionCombineRule(handle) {\n      var ret = wasm.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, handle);\n      return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n  }, {\n    key: \"coSetRestitutionCombineRule\",\n    value: function coSetRestitutionCombineRule(handle, rule) {\n      wasm.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n  }, {\n    key: \"coSetCollisionGroups\",\n    value: function coSetCollisionGroups(handle, groups) {\n      wasm.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n  }, {\n    key: \"coSetSolverGroups\",\n    value: function coSetSolverGroups(handle, groups) {\n      wasm.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n  }, {\n    key: \"coSetActiveHooks\",\n    value: function coSetActiveHooks(handle, hooks) {\n      wasm.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n  }, {\n    key: \"coSetActiveEvents\",\n    value: function coSetActiveEvents(handle, events) {\n      wasm.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n  }, {\n    key: \"coSetActiveCollisionTypes\",\n    value: function coSetActiveCollisionTypes(handle, types) {\n      wasm.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n  }, {\n    key: \"coSetShape\",\n    value: function coSetShape(handle, shape) {\n      _assertClass(shape, RawShape);\n      wasm.rawcolliderset_coSetShape(this.__wbg_ptr, handle, shape.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} threshold\n    */\n  }, {\n    key: \"coSetContactForceEventThreshold\",\n    value: function coSetContactForceEventThreshold(handle, threshold) {\n      wasm.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, handle, threshold);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} density\n    */\n  }, {\n    key: \"coSetDensity\",\n    value: function coSetDensity(handle, density) {\n      wasm.rawcolliderset_coSetDensity(this.__wbg_ptr, handle, density);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    */\n  }, {\n    key: \"coSetMass\",\n    value: function coSetMass(handle, mass) {\n      wasm.rawcolliderset_coSetMass(this.__wbg_ptr, handle, mass);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    */\n  }, {\n    key: \"coSetMassProperties\",\n    value: function coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia) {\n      _assertClass(centerOfMass, RawVector);\n      wasm.rawcolliderset_coSetMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia);\n    }\n  }, {\n    key: \"len\",\n    value: function len() {\n      var ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"contains\",\n    value: function contains(handle) {\n      var ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} massPropsMode\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {number} contactForceEventThreshold\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"createCollider\",\n    value: function createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies) {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(shape, RawShape);\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_createCollider(retptr, this.__wbg_ptr, enabled, shape.__wbg_ptr, translation.__wbg_ptr, rotation.__wbg_ptr, massPropsMode, mass, centerOfMass.__wbg_ptr, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r2 = getFloat64Memory0()[retptr / 8 + 1];\n        return r0 === 0 ? undefined : r2;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"remove\",\n    value: function remove(handle, islands, bodies, wakeUp) {\n      _assertClass(islands, RawIslandManager);\n      _assertClass(bodies, RawRigidBodySet);\n      wasm.rawcolliderset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, bodies.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"isHandleValid\",\n    value: function isHandleValid(handle) {\n      var ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n  }, {\n    key: \"forEachColliderHandle\",\n    value: function forEachColliderHandle(f) {\n      try {\n        wasm.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, addBorrowedObject(f));\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawColliderSet.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawColliderSet;\n}();\n/**\n*/\nvar RawContactForceEvent = /*#__PURE__*/function () {\n  function RawContactForceEvent() {\n    _classCallCheck(this, RawContactForceEvent);\n  }\n  _createClass(RawContactForceEvent, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawcontactforceevent_free(ptr);\n    }\n    /**\n    * The first collider involved in the contact.\n    * @returns {number}\n    */\n  }, {\n    key: \"collider1\",\n    value: function collider1() {\n      var ret = wasm.rawcontactforceevent_collider1(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * The second collider involved in the contact.\n    * @returns {number}\n    */\n  }, {\n    key: \"collider2\",\n    value: function collider2() {\n      var ret = wasm.rawcontactforceevent_collider2(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * The sum of all the forces between the two colliders.\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"total_force\",\n    value: function total_force() {\n      var ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * The sum of the magnitudes of each force between the two colliders.\n    *\n    * Note that this is **not** the same as the magnitude of `self.total_force`.\n    * Here we are summing the magnitude of all the forces, instead of taking\n    * the magnitude of their sum.\n    * @returns {number}\n    */\n  }, {\n    key: \"total_force_magnitude\",\n    value: function total_force_magnitude() {\n      var ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * The world-space (unit) direction of the force with strongest magnitude.\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"max_force_direction\",\n    value: function max_force_direction() {\n      var ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * The magnitude of the largest force at a contact point of this contact pair.\n    * @returns {number}\n    */\n  }, {\n    key: \"max_force_magnitude\",\n    value: function max_force_magnitude() {\n      var ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n      return ret;\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawContactForceEvent.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawContactForceEvent;\n}();\n/**\n*/\nvar RawContactManifold = /*#__PURE__*/function () {\n  function RawContactManifold() {\n    _classCallCheck(this, RawContactManifold);\n  }\n  _createClass(RawContactManifold, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"normal\",\n    value: function normal() {\n      var ret = wasm.rawcontactmanifold_normal(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"local_n1\",\n    value: function local_n1() {\n      var ret = wasm.rawcontactmanifold_local_n1(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"local_n2\",\n    value: function local_n2() {\n      var ret = wasm.rawcontactmanifold_local_n2(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"subshape1\",\n    value: function subshape1() {\n      var ret = wasm.rawcontactmanifold_subshape1(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"subshape2\",\n    value: function subshape2() {\n      var ret = wasm.rawcontactmanifold_subshape2(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"num_contacts\",\n    value: function num_contacts() {\n      var ret = wasm.rawcontactmanifold_num_contacts(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n  }, {\n    key: \"contact_local_p1\",\n    value: function contact_local_p1(i) {\n      var ret = wasm.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, i);\n      return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n  }, {\n    key: \"contact_local_p2\",\n    value: function contact_local_p2(i) {\n      var ret = wasm.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, i);\n      return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n  }, {\n    key: \"contact_dist\",\n    value: function contact_dist(i) {\n      var ret = wasm.rawcontactmanifold_contact_dist(this.__wbg_ptr, i);\n      return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n  }, {\n    key: \"contact_fid1\",\n    value: function contact_fid1(i) {\n      var ret = wasm.rawcontactmanifold_contact_fid1(this.__wbg_ptr, i);\n      return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n  }, {\n    key: \"contact_fid2\",\n    value: function contact_fid2(i) {\n      var ret = wasm.rawcontactmanifold_contact_fid2(this.__wbg_ptr, i);\n      return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n  }, {\n    key: \"contact_impulse\",\n    value: function contact_impulse(i) {\n      var ret = wasm.rawcontactmanifold_contact_impulse(this.__wbg_ptr, i);\n      return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n  }, {\n    key: \"contact_tangent_impulse\",\n    value: function contact_tangent_impulse(i) {\n      var ret = wasm.rawcontactmanifold_contact_tangent_impulse(this.__wbg_ptr, i);\n      return ret;\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"num_solver_contacts\",\n    value: function num_solver_contacts() {\n      var ret = wasm.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n  }, {\n    key: \"solver_contact_point\",\n    value: function solver_contact_point(i) {\n      var ret = wasm.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, i);\n      return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n  }, {\n    key: \"solver_contact_dist\",\n    value: function solver_contact_dist(i) {\n      var ret = wasm.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, i);\n      return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n  }, {\n    key: \"solver_contact_friction\",\n    value: function solver_contact_friction(i) {\n      var ret = wasm.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, i);\n      return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n  }, {\n    key: \"solver_contact_restitution\",\n    value: function solver_contact_restitution(i) {\n      var ret = wasm.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, i);\n      return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"solver_contact_tangent_velocity\",\n    value: function solver_contact_tangent_velocity(i) {\n      var ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, i);\n      return RawVector.__wrap(ret);\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawContactManifold.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawContactManifold;\n}();\n/**\n*/\nvar RawContactPair = /*#__PURE__*/function () {\n  function RawContactPair() {\n    _classCallCheck(this, RawContactPair);\n  }\n  _createClass(RawContactPair, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"collider1\",\n    value: function collider1() {\n      var ret = wasm.rawcontactpair_collider1(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"collider2\",\n    value: function collider2() {\n      var ret = wasm.rawcontactpair_collider2(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"numContactManifolds\",\n    value: function numContactManifolds() {\n      var ret = wasm.rawcontactpair_numContactManifolds(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n  }, {\n    key: \"contactManifold\",\n    value: function contactManifold(i) {\n      var ret = wasm.rawcontactpair_contactManifold(this.__wbg_ptr, i);\n      return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawContactPair.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawContactPair;\n}();\n/**\n*/\nvar RawDebugRenderPipeline = /*#__PURE__*/function () {\n  /**\n  */\n  function RawDebugRenderPipeline() {\n    _classCallCheck(this, RawDebugRenderPipeline);\n    var ret = wasm.rawdebugrenderpipeline_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @returns {Float32Array}\n  */\n  _createClass(RawDebugRenderPipeline, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawdebugrenderpipeline_free(ptr);\n    }\n  }, {\n    key: \"vertices\",\n    value: function vertices() {\n      var ret = wasm.rawdebugrenderpipeline_vertices(this.__wbg_ptr);\n      return takeObject(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n  }, {\n    key: \"colors\",\n    value: function colors() {\n      var ret = wasm.rawdebugrenderpipeline_colors(this.__wbg_ptr);\n      return takeObject(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @param {RawNarrowPhase} narrow_phase\n    */\n  }, {\n    key: \"render\",\n    value: function render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n      _assertClass(bodies, RawRigidBodySet);\n      _assertClass(colliders, RawColliderSet);\n      _assertClass(impulse_joints, RawImpulseJointSet);\n      _assertClass(multibody_joints, RawMultibodyJointSet);\n      _assertClass(narrow_phase, RawNarrowPhase);\n      wasm.rawdebugrenderpipeline_render(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr, narrow_phase.__wbg_ptr);\n    }\n  }]);\n  return RawDebugRenderPipeline;\n}();\n/**\n*/\nvar RawDeserializedWorld = /*#__PURE__*/function () {\n  function RawDeserializedWorld() {\n    _classCallCheck(this, RawDeserializedWorld);\n  }\n  _createClass(RawDeserializedWorld, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n  }, {\n    key: \"takeGravity\",\n    value: function takeGravity() {\n      var ret = wasm.rawdeserializedworld_takeGravity(this.__wbg_ptr);\n      return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n  }, {\n    key: \"takeIntegrationParameters\",\n    value: function takeIntegrationParameters() {\n      var ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);\n      return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n  }, {\n    key: \"takeIslandManager\",\n    value: function takeIslandManager() {\n      var ret = wasm.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);\n      return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n  }, {\n    key: \"takeBroadPhase\",\n    value: function takeBroadPhase() {\n      var ret = wasm.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);\n      return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n  }, {\n    key: \"takeNarrowPhase\",\n    value: function takeNarrowPhase() {\n      var ret = wasm.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);\n      return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n  }, {\n    key: \"takeBodies\",\n    value: function takeBodies() {\n      var ret = wasm.rawdeserializedworld_takeBodies(this.__wbg_ptr);\n      return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n  }, {\n    key: \"takeColliders\",\n    value: function takeColliders() {\n      var ret = wasm.rawdeserializedworld_takeColliders(this.__wbg_ptr);\n      return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawImpulseJointSet | undefined}\n    */\n  }, {\n    key: \"takeImpulseJoints\",\n    value: function takeImpulseJoints() {\n      var ret = wasm.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);\n      return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawMultibodyJointSet | undefined}\n    */\n  }, {\n    key: \"takeMultibodyJoints\",\n    value: function takeMultibodyJoints() {\n      var ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);\n      return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawDeserializedWorld.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawDeserializedWorld;\n}();\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nvar RawEventQueue = /*#__PURE__*/function () {\n  /**\n  * Creates a new event collector.\n  *\n  * # Parameters\n  * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n  * be automatically drained before each `world.step(collector)`. If false, the collector will\n  * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n  * RAM if no drain is performed.\n  * @param {boolean} autoDrain\n  */\n  function RawEventQueue(autoDrain) {\n    _classCallCheck(this, RawEventQueue);\n    var ret = wasm.raweventqueue_new(autoDrain);\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * Applies the given javascript closure on each collision event of this collector, then clear\n  * the internal collision event buffer.\n  *\n  * # Parameters\n  * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n  * closure should take three arguments: two integers representing the handles of the colliders\n  * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n  * (false).\n  * @param {Function} f\n  */\n  _createClass(RawEventQueue, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_raweventqueue_free(ptr);\n    }\n  }, {\n    key: \"drainCollisionEvents\",\n    value: function drainCollisionEvents(f) {\n      try {\n        wasm.raweventqueue_drainCollisionEvents(this.__wbg_ptr, addBorrowedObject(f));\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @param {Function} f\n    */\n  }, {\n    key: \"drainContactForceEvents\",\n    value: function drainContactForceEvents(f) {\n      try {\n        wasm.raweventqueue_drainContactForceEvents(this.__wbg_ptr, addBorrowedObject(f));\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      wasm.raweventqueue_clear(this.__wbg_ptr);\n    }\n  }]);\n  return RawEventQueue;\n}();\n/**\n*/\nvar RawGenericJoint = /*#__PURE__*/function () {\n  function RawGenericJoint() {\n    _classCallCheck(this, RawGenericJoint);\n  }\n  _createClass(RawGenericJoint, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawgenericjoint_free(ptr);\n    }\n    /**\n    * @param {number} rest_length\n    * @param {number} stiffness\n    * @param {number} damping\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawGenericJoint.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }, {\n    key: \"spring\",\n    value: function spring(rest_length, stiffness, damping, anchor1, anchor2) {\n      _assertClass(anchor1, RawVector);\n      _assertClass(anchor2, RawVector);\n      var ret = wasm.rawgenericjoint_spring(rest_length, stiffness, damping, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n      return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * @param {number} length\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n  }, {\n    key: \"rope\",\n    value: function rope(length, anchor1, anchor2) {\n      _assertClass(anchor1, RawVector);\n      _assertClass(anchor2, RawVector);\n      var ret = wasm.rawgenericjoint_rope(length, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n      return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawGenericJoint | undefined}\n    */\n  }, {\n    key: \"prismatic\",\n    value: function prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n      _assertClass(anchor1, RawVector);\n      _assertClass(anchor2, RawVector);\n      _assertClass(axis, RawVector);\n      var ret = wasm.rawgenericjoint_prismatic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, limitsEnabled, limitsMin, limitsMax);\n      return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawGenericJoint}\n    */\n  }, {\n    key: \"fixed\",\n    value: function fixed(anchor1, axes1, anchor2, axes2) {\n      _assertClass(anchor1, RawVector);\n      _assertClass(axes1, RawRotation);\n      _assertClass(anchor2, RawVector);\n      _assertClass(axes2, RawRotation);\n      var ret = wasm.rawgenericjoint_fixed(anchor1.__wbg_ptr, axes1.__wbg_ptr, anchor2.__wbg_ptr, axes2.__wbg_ptr);\n      return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint | undefined}\n    */\n  }, {\n    key: \"revolute\",\n    value: function revolute(anchor1, anchor2) {\n      _assertClass(anchor1, RawVector);\n      _assertClass(anchor2, RawVector);\n      var ret = wasm.rawgenericjoint_revolute(anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n      return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n  }]);\n  return RawGenericJoint;\n}();\n/**\n*/\nvar RawImpulseJointSet = /*#__PURE__*/function () {\n  /**\n  */\n  function RawImpulseJointSet() {\n    _classCallCheck(this, RawImpulseJointSet);\n    var ret = wasm.rawimpulsejointset_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @param {RawGenericJoint} params\n  * @param {number} parent1\n  * @param {number} parent2\n  * @param {boolean} wake_up\n  * @returns {number}\n  */\n  _createClass(RawImpulseJointSet, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawimpulsejointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n  }, {\n    key: \"jointType\",\n    value: function jointType(handle) {\n      var ret = wasm.rawimpulsejointset_jointType(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"jointBodyHandle1\",\n    value: function jointBodyHandle1(handle) {\n      var ret = wasm.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"jointBodyHandle2\",\n    value: function jointBodyHandle2(handle) {\n      var ret = wasm.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n  }, {\n    key: \"jointFrameX1\",\n    value: function jointFrameX1(handle) {\n      var ret = wasm.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, handle);\n      return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n  }, {\n    key: \"jointFrameX2\",\n    value: function jointFrameX2(handle) {\n      var ret = wasm.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, handle);\n      return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"jointAnchor1\",\n    value: function jointAnchor1(handle) {\n      var ret = wasm.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, handle);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"jointAnchor2\",\n    value: function jointAnchor2(handle) {\n      var ret = wasm.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, handle);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * Sets the position of the first local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n  }, {\n    key: \"jointSetAnchor1\",\n    value: function jointSetAnchor1(handle, newPos) {\n      _assertClass(newPos, RawVector);\n      wasm.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Sets the position of the second local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n  }, {\n    key: \"jointSetAnchor2\",\n    value: function jointSetAnchor2(handle, newPos) {\n      _assertClass(newPos, RawVector);\n      wasm.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"jointContactsEnabled\",\n    value: function jointContactsEnabled(handle) {\n      var ret = wasm.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n  }, {\n    key: \"jointSetContactsEnabled\",\n    value: function jointSetContactsEnabled(handle, enabled) {\n      wasm.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n  }, {\n    key: \"jointLimitsEnabled\",\n    value: function jointLimitsEnabled(handle, axis) {\n      var ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n      return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n  }, {\n    key: \"jointLimitsMin\",\n    value: function jointLimitsMin(handle, axis) {\n      var ret = wasm.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n      return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n  }, {\n    key: \"jointLimitsMax\",\n    value: function jointLimitsMax(handle, axis) {\n      var ret = wasm.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n      return ret;\n    }\n    /**\n    * Enables and sets the joint limits\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} min\n    * @param {number} max\n    */\n  }, {\n    key: \"jointSetLimits\",\n    value: function jointSetLimits(handle, axis, min, max) {\n      wasm.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, handle, axis, min, max);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {RawMotorModel} model\n    */\n  }, {\n    key: \"jointConfigureMotorModel\",\n    value: function jointConfigureMotorModel(handle, axis, model) {\n      wasm.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, handle, axis, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n  }, {\n    key: \"jointConfigureMotorVelocity\",\n    value: function jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n      wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, handle, axis, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n  }, {\n    key: \"jointConfigureMotorPosition\",\n    value: function jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n      wasm.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n  }, {\n    key: \"jointConfigureMotor\",\n    value: function jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n      wasm.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n  }, {\n    key: \"createJoint\",\n    value: function createJoint(params, parent1, parent2, wake_up) {\n      _assertClass(params, RawGenericJoint);\n      var ret = wasm.rawimpulsejointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wake_up);\n      return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"remove\",\n    value: function remove(handle, wakeUp) {\n      wasm.rawimpulsejointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"len\",\n    value: function len() {\n      var ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"contains\",\n    value: function contains(handle) {\n      var ret = wasm.rawimpulsejointset_contains(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n  }, {\n    key: \"forEachJointHandle\",\n    value: function forEachJointHandle(f) {\n      try {\n        wasm.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n  }, {\n    key: \"forEachJointAttachedToRigidBody\",\n    value: function forEachJointAttachedToRigidBody(body, f) {\n      try {\n        wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawImpulseJointSet.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawImpulseJointSet;\n}();\n/**\n*/\nvar RawIntegrationParameters = /*#__PURE__*/function () {\n  /**\n  */\n  function RawIntegrationParameters() {\n    _classCallCheck(this, RawIntegrationParameters);\n    var ret = wasm.rawintegrationparameters_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @returns {number}\n  */\n  _createClass(RawIntegrationParameters, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n  }, {\n    key: \"dt\",\n    get: function get() {\n      var ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {number}\n    */,\n    set:\n    /**\n    * @param {number} value\n    */\n    function set(value) {\n      wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n  }, {\n    key: \"erp\",\n    get: function get() {\n      var ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {number}\n    */,\n    set: function set(value) {\n      wasm.rawintegrationparameters_set_erp(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n  }, {\n    key: \"allowedLinearError\",\n    get: function get() {\n      var ret = wasm.rawintegrationparameters_allowedLinearError(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {number}\n    */,\n    set: function set(value) {\n      wasm.rawintegrationparameters_set_allowedLinearError(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n  }, {\n    key: \"predictionDistance\",\n    get: function get() {\n      var ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {number}\n    */,\n    set: function set(value) {\n      wasm.rawintegrationparameters_set_predictionDistance(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n  }, {\n    key: \"numSolverIterations\",\n    get: function get() {\n      var ret = wasm.rawintegrationparameters_numSolverIterations(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */,\n    set: function set(value) {\n      wasm.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n  }, {\n    key: \"numAdditionalFrictionIterations\",\n    get: function get() {\n      var ret = wasm.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */,\n    set: function set(value) {\n      wasm.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n  }, {\n    key: \"numInternalPgsIterations\",\n    get: function get() {\n      var ret = wasm.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */,\n    set: function set(value) {\n      wasm.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n  }, {\n    key: \"minIslandSize\",\n    get: function get() {\n      var ret = wasm.rawintegrationparameters_minIslandSize(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */,\n    set: function set(value) {\n      wasm.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n  }, {\n    key: \"maxCcdSubsteps\",\n    get: function get() {\n      var ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr);\n      return ret >>> 0;\n    },\n    set: function set(value) {\n      wasm.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, value);\n    }\n    /**\n    */\n  }, {\n    key: \"switchToStandardPgsSolver\",\n    value: function switchToStandardPgsSolver() {\n      wasm.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);\n    }\n    /**\n    */\n  }, {\n    key: \"switchToSmallStepsPgsSolver\",\n    value: function switchToSmallStepsPgsSolver() {\n      wasm.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawIntegrationParameters.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawIntegrationParameters;\n}();\n/**\n*/\nvar RawIslandManager = /*#__PURE__*/function () {\n  /**\n  */\n  function RawIslandManager() {\n    _classCallCheck(this, RawIslandManager);\n    var ret = wasm.rawislandmanager_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * Applies the given JavaScript function to the integer handle of each active rigid-body\n  * managed by this island manager.\n  *\n  * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n  * the physics engine in order to save computational power. A sleeping rigid-body never moves\n  * unless it is moved manually by the user.\n  *\n  * # Parameters\n  * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n  *   set. Called as `f(collider)`.\n  * @param {Function} f\n  */\n  _createClass(RawIslandManager, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawislandmanager_free(ptr);\n    }\n  }, {\n    key: \"forEachActiveRigidBodyHandle\",\n    value: function forEachActiveRigidBodyHandle(f) {\n      try {\n        wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawIslandManager.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawIslandManager;\n}();\n/**\n*/\nvar RawKinematicCharacterController = /*#__PURE__*/function () {\n  /**\n  * @param {number} offset\n  */\n  function RawKinematicCharacterController(offset) {\n    _classCallCheck(this, RawKinematicCharacterController);\n    var ret = wasm.rawkinematiccharactercontroller_new(offset);\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @returns {RawVector}\n  */\n  _createClass(RawKinematicCharacterController, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawkinematiccharactercontroller_free(ptr);\n    }\n  }, {\n    key: \"up\",\n    value: function up() {\n      var ret = wasm.rawkinematiccharactercontroller_up(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} vector\n    */\n  }, {\n    key: \"setUp\",\n    value: function setUp(vector) {\n      _assertClass(vector, RawVector);\n      wasm.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, vector.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"offset\",\n    value: function offset() {\n      var ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @param {number} value\n    */\n  }, {\n    key: \"setOffset\",\n    value: function setOffset(value) {\n      wasm.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, value);\n    }\n    /**\n    * @returns {boolean}\n    */\n  }, {\n    key: \"slideEnabled\",\n    value: function slideEnabled() {\n      var ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr);\n      return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    */\n  }, {\n    key: \"setSlideEnabled\",\n    value: function setSlideEnabled(enabled) {\n      wasm.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"autostepMaxHeight\",\n    value: function autostepMaxHeight() {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawkinematiccharactercontroller_autostepMaxHeight(retptr, this.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getFloat32Memory0()[retptr / 4 + 1];\n        return r0 === 0 ? undefined : r1;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"autostepMinWidth\",\n    value: function autostepMinWidth() {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawkinematiccharactercontroller_autostepMinWidth(retptr, this.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getFloat32Memory0()[retptr / 4 + 1];\n        return r0 === 0 ? undefined : r1;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n  }, {\n    key: \"autostepIncludesDynamicBodies\",\n    value: function autostepIncludesDynamicBodies() {\n      var ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);\n      return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n  }, {\n    key: \"autostepEnabled\",\n    value: function autostepEnabled() {\n      var ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr);\n      return ret !== 0;\n    }\n    /**\n    * @param {number} maxHeight\n    * @param {number} minWidth\n    * @param {boolean} includeDynamicBodies\n    */\n  }, {\n    key: \"enableAutostep\",\n    value: function enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n      wasm.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n    */\n  }, {\n    key: \"disableAutostep\",\n    value: function disableAutostep() {\n      wasm.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"maxSlopeClimbAngle\",\n    value: function maxSlopeClimbAngle() {\n      var ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n  }, {\n    key: \"setMaxSlopeClimbAngle\",\n    value: function setMaxSlopeClimbAngle(angle) {\n      wasm.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"minSlopeSlideAngle\",\n    value: function minSlopeSlideAngle() {\n      var ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n  }, {\n    key: \"setMinSlopeSlideAngle\",\n    value: function setMinSlopeSlideAngle(angle) {\n      wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"snapToGroundDistance\",\n    value: function snapToGroundDistance() {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawkinematiccharactercontroller_snapToGroundDistance(retptr, this.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getFloat32Memory0()[retptr / 4 + 1];\n        return r0 === 0 ? undefined : r1;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n    /**\n    * @param {number} distance\n    */\n  }, {\n    key: \"enableSnapToGround\",\n    value: function enableSnapToGround(distance) {\n      wasm.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, distance);\n    }\n    /**\n    */\n  }, {\n    key: \"disableSnapToGround\",\n    value: function disableSnapToGround() {\n      wasm.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n  }, {\n    key: \"snapToGroundEnabled\",\n    value: function snapToGroundEnabled() {\n      var ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr);\n      return ret !== 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} collider_handle\n    * @param {RawVector} desired_translation_delta\n    * @param {boolean} apply_impulses_to_dynamic_bodies\n    * @param {number | undefined} character_mass\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n  }, {\n    key: \"computeColliderMovement\",\n    value: function computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation_delta, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n      try {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(queries, RawQueryPipeline);\n        _assertClass(desired_translation_delta, RawVector);\n        wasm.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, collider_handle, desired_translation_delta.__wbg_ptr, apply_impulses_to_dynamic_bodies, !isLikeNone(character_mass), isLikeNone(character_mass) ? 0 : character_mass, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"computedMovement\",\n    value: function computedMovement() {\n      var ret = wasm.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n  }, {\n    key: \"computedGrounded\",\n    value: function computedGrounded() {\n      var ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr);\n      return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"numComputedCollisions\",\n    value: function numComputedCollisions() {\n      var ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @param {RawCharacterCollision} collision\n    * @returns {boolean}\n    */\n  }, {\n    key: \"computedCollision\",\n    value: function computedCollision(i, collision) {\n      _assertClass(collision, RawCharacterCollision);\n      var ret = wasm.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, i, collision.__wbg_ptr);\n      return ret !== 0;\n    }\n  }]);\n  return RawKinematicCharacterController;\n}();\n/**\n*/\nvar RawMultibodyJointSet = /*#__PURE__*/function () {\n  /**\n  */\n  function RawMultibodyJointSet() {\n    _classCallCheck(this, RawMultibodyJointSet);\n    var ret = wasm.rawmultibodyjointset_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @param {RawGenericJoint} params\n  * @param {number} parent1\n  * @param {number} parent2\n  * @param {boolean} wakeUp\n  * @returns {number}\n  */\n  _createClass(RawMultibodyJointSet, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawmultibodyjointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n  }, {\n    key: \"jointType\",\n    value: function jointType(handle) {\n      var ret = wasm.rawmultibodyjointset_jointType(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n  }, {\n    key: \"jointFrameX1\",\n    value: function jointFrameX1(handle) {\n      var ret = wasm.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, handle);\n      return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n  }, {\n    key: \"jointFrameX2\",\n    value: function jointFrameX2(handle) {\n      var ret = wasm.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, handle);\n      return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"jointAnchor1\",\n    value: function jointAnchor1(handle) {\n      var ret = wasm.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, handle);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"jointAnchor2\",\n    value: function jointAnchor2(handle) {\n      var ret = wasm.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, handle);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"jointContactsEnabled\",\n    value: function jointContactsEnabled(handle) {\n      var ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n  }, {\n    key: \"jointSetContactsEnabled\",\n    value: function jointSetContactsEnabled(handle, enabled) {\n      wasm.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n  }, {\n    key: \"jointLimitsEnabled\",\n    value: function jointLimitsEnabled(handle, axis) {\n      var ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n      return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n  }, {\n    key: \"jointLimitsMin\",\n    value: function jointLimitsMin(handle, axis) {\n      var ret = wasm.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n      return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n  }, {\n    key: \"jointLimitsMax\",\n    value: function jointLimitsMax(handle, axis) {\n      var ret = wasm.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n      return ret;\n    }\n  }, {\n    key: \"createJoint\",\n    value: function createJoint(params, parent1, parent2, wakeUp) {\n      _assertClass(params, RawGenericJoint);\n      var ret = wasm.rawmultibodyjointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wakeUp);\n      return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"remove\",\n    value: function remove(handle, wakeUp) {\n      wasm.rawmultibodyjointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"contains\",\n    value: function contains(handle) {\n      var ret = wasm.rawmultibodyjointset_contains(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n  }, {\n    key: \"forEachJointHandle\",\n    value: function forEachJointHandle(f) {\n      try {\n        wasm.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n  }, {\n    key: \"forEachJointAttachedToRigidBody\",\n    value: function forEachJointAttachedToRigidBody(body, f) {\n      try {\n        wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawMultibodyJointSet.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawMultibodyJointSet;\n}();\n/**\n*/\nvar RawNarrowPhase = /*#__PURE__*/function () {\n  /**\n  */\n  function RawNarrowPhase() {\n    _classCallCheck(this, RawNarrowPhase);\n    var ret = wasm.rawnarrowphase_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @param {number} handle1\n  * @param {Function} f\n  */\n  _createClass(RawNarrowPhase, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n  }, {\n    key: \"contact_pairs_with\",\n    value: function contact_pairs_with(handle1, f) {\n      wasm.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n  }, {\n    key: \"contact_pair\",\n    value: function contact_pair(handle1, handle2) {\n      var ret = wasm.rawnarrowphase_contact_pair(this.__wbg_ptr, handle1, handle2);\n      return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n  }, {\n    key: \"intersection_pairs_with\",\n    value: function intersection_pairs_with(handle1, f) {\n      wasm.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n  }, {\n    key: \"intersection_pair\",\n    value: function intersection_pair(handle1, handle2) {\n      var ret = wasm.rawnarrowphase_intersection_pair(this.__wbg_ptr, handle1, handle2);\n      return ret !== 0;\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawNarrowPhase.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawNarrowPhase;\n}();\n/**\n*/\nvar RawPhysicsPipeline = /*#__PURE__*/function () {\n  /**\n  */\n  function RawPhysicsPipeline() {\n    _classCallCheck(this, RawPhysicsPipeline);\n    var ret = wasm.rawphysicspipeline_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @param {RawVector} gravity\n  * @param {RawIntegrationParameters} integrationParameters\n  * @param {RawIslandManager} islands\n  * @param {RawBroadPhase} broadPhase\n  * @param {RawNarrowPhase} narrowPhase\n  * @param {RawRigidBodySet} bodies\n  * @param {RawColliderSet} colliders\n  * @param {RawImpulseJointSet} joints\n  * @param {RawMultibodyJointSet} articulations\n  * @param {RawCCDSolver} ccd_solver\n  */\n  _createClass(RawPhysicsPipeline, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n  }, {\n    key: \"step\",\n    value: function step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n      _assertClass(gravity, RawVector);\n      _assertClass(integrationParameters, RawIntegrationParameters);\n      _assertClass(islands, RawIslandManager);\n      _assertClass(broadPhase, RawBroadPhase);\n      _assertClass(narrowPhase, RawNarrowPhase);\n      _assertClass(bodies, RawRigidBodySet);\n      _assertClass(colliders, RawColliderSet);\n      _assertClass(joints, RawImpulseJointSet);\n      _assertClass(articulations, RawMultibodyJointSet);\n      _assertClass(ccd_solver, RawCCDSolver);\n      wasm.rawphysicspipeline_step(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n  }, {\n    key: \"stepWithEvents\",\n    value: function stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n      _assertClass(gravity, RawVector);\n      _assertClass(integrationParameters, RawIntegrationParameters);\n      _assertClass(islands, RawIslandManager);\n      _assertClass(broadPhase, RawBroadPhase);\n      _assertClass(narrowPhase, RawNarrowPhase);\n      _assertClass(bodies, RawRigidBodySet);\n      _assertClass(colliders, RawColliderSet);\n      _assertClass(joints, RawImpulseJointSet);\n      _assertClass(articulations, RawMultibodyJointSet);\n      _assertClass(ccd_solver, RawCCDSolver);\n      _assertClass(eventQueue, RawEventQueue);\n      wasm.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr, eventQueue.__wbg_ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n  }]);\n  return RawPhysicsPipeline;\n}();\n/**\n*/\nvar RawPointColliderProjection = /*#__PURE__*/function () {\n  function RawPointColliderProjection() {\n    _classCallCheck(this, RawPointColliderProjection);\n  }\n  _createClass(RawPointColliderProjection, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"colliderHandle\",\n    value: function colliderHandle() {\n      var ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"point\",\n    value: function point() {\n      var ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n  }, {\n    key: \"isInside\",\n    value: function isInside() {\n      var ret = wasm.rawpointcolliderprojection_isInside(this.__wbg_ptr);\n      return ret !== 0;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n  }, {\n    key: \"featureType\",\n    value: function featureType() {\n      var ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"featureId\",\n    value: function featureId() {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return r0 === 0 ? undefined : r1 >>> 0;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawPointColliderProjection.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawPointColliderProjection;\n}();\n/**\n*/\nvar RawPointProjection = /*#__PURE__*/function () {\n  function RawPointProjection() {\n    _classCallCheck(this, RawPointProjection);\n  }\n  _createClass(RawPointProjection, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawpointprojection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"point\",\n    value: function point() {\n      var ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n  }, {\n    key: \"isInside\",\n    value: function isInside() {\n      var ret = wasm.rawpointprojection_isInside(this.__wbg_ptr);\n      return ret !== 0;\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawPointProjection.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawPointProjection;\n}();\n/**\n*/\nvar RawQueryPipeline = /*#__PURE__*/function () {\n  /**\n  */\n  function RawQueryPipeline() {\n    _classCallCheck(this, RawQueryPipeline);\n    var ret = wasm.rawquerypipeline_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @param {RawRigidBodySet} bodies\n  * @param {RawColliderSet} colliders\n  */\n  _createClass(RawQueryPipeline, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n  }, {\n    key: \"update\",\n    value: function update(bodies, colliders) {\n      _assertClass(bodies, RawRigidBodySet);\n      _assertClass(colliders, RawColliderSet);\n      wasm.rawquerypipeline_update(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderToi | undefined}\n    */\n  }, {\n    key: \"castRay\",\n    value: function castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n      try {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        var ret = wasm.rawquerypipeline_castRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        return ret === 0 ? undefined : RawRayColliderToi.__wrap(ret);\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n  }, {\n    key: \"castRayAndGetNormal\",\n    value: function castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n      try {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        var ret = wasm.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n  }, {\n    key: \"intersectionsWithRay\",\n    value: function intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n      try {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        wasm.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n      } finally {\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"intersectionWithShape\",\n    value: function intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(shape, RawShape);\n        wasm.rawquerypipeline_intersectionWithShape(retptr, this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r2 = getFloat64Memory0()[retptr / 8 + 1];\n        return r0 === 0 ? undefined : r2;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n  }, {\n    key: \"projectPoint\",\n    value: function projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n      try {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(point, RawVector);\n        var ret = wasm.rawquerypipeline_projectPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n  }, {\n    key: \"projectPointAndGetFeature\",\n    value: function projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n      try {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(point, RawVector);\n        var ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n  }, {\n    key: \"intersectionsWithPoint\",\n    value: function intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n      try {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(point, RawVector);\n        wasm.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n      } finally {\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n  }, {\n    key: \"castShape\",\n    value: function castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n      try {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(shapeVel, RawVector);\n        _assertClass(shape, RawShape);\n        var ret = wasm.rawquerypipeline_castShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shapeVel.__wbg_ptr, shape.__wbg_ptr, maxToi, stop_at_penetration, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n  }, {\n    key: \"intersectionsWithShape\",\n    value: function intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n      try {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(shape, RawShape);\n        wasm.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n      } finally {\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n  }, {\n    key: \"collidersWithAabbIntersectingAabb\",\n    value: function collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n      try {\n        _assertClass(aabbCenter, RawVector);\n        _assertClass(aabbHalfExtents, RawVector);\n        wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, aabbCenter.__wbg_ptr, aabbHalfExtents.__wbg_ptr, addBorrowedObject(callback));\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n  }]);\n  return RawQueryPipeline;\n}();\n/**\n*/\nvar RawRayColliderIntersection = /*#__PURE__*/function () {\n  function RawRayColliderIntersection() {\n    _classCallCheck(this, RawRayColliderIntersection);\n  }\n  _createClass(RawRayColliderIntersection, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"colliderHandle\",\n    value: function colliderHandle() {\n      var ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"normal\",\n    value: function normal() {\n      var ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"toi\",\n    value: function toi() {\n      var ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n  }, {\n    key: \"featureType\",\n    value: function featureType() {\n      var ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"featureId\",\n    value: function featureId() {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return r0 === 0 ? undefined : r1 >>> 0;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawRayColliderIntersection.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawRayColliderIntersection;\n}();\n/**\n*/\nvar RawRayColliderToi = /*#__PURE__*/function () {\n  function RawRayColliderToi() {\n    _classCallCheck(this, RawRayColliderToi);\n  }\n  _createClass(RawRayColliderToi, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawraycollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"colliderHandle\",\n    value: function colliderHandle() {\n      var ret = wasm.rawcontactforceevent_collider1(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"toi\",\n    value: function toi() {\n      var ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n      return ret;\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawRayColliderToi.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawRayColliderToi;\n}();\n/**\n*/\nvar RawRayIntersection = /*#__PURE__*/function () {\n  function RawRayIntersection() {\n    _classCallCheck(this, RawRayIntersection);\n  }\n  _createClass(RawRayIntersection, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawrayintersection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"normal\",\n    value: function normal() {\n      var ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"toi\",\n    value: function toi() {\n      var ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n  }, {\n    key: \"featureType\",\n    value: function featureType() {\n      var ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n  }, {\n    key: \"featureId\",\n    value: function featureId() {\n      try {\n        var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return r0 === 0 ? undefined : r1 >>> 0;\n      } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n      }\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawRayIntersection.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawRayIntersection;\n}();\n/**\n*/\nvar RawRigidBodySet = /*#__PURE__*/function () {\n  /**\n  */\n  function RawRigidBodySet() {\n    _classCallCheck(this, RawRigidBodySet);\n    var ret = wasm.rawrigidbodyset_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @param {boolean} enabled\n  * @param {RawVector} translation\n  * @param {RawRotation} rotation\n  * @param {number} gravityScale\n  * @param {number} mass\n  * @param {boolean} massOnly\n  * @param {RawVector} centerOfMass\n  * @param {RawVector} linvel\n  * @param {number} angvel\n  * @param {number} principalAngularInertia\n  * @param {boolean} translationEnabledX\n  * @param {boolean} translationEnabledY\n  * @param {boolean} rotationsEnabled\n  * @param {number} linearDamping\n  * @param {number} angularDamping\n  * @param {RawRigidBodyType} rb_type\n  * @param {boolean} canSleep\n  * @param {boolean} sleeping\n  * @param {boolean} ccdEnabled\n  * @param {number} dominanceGroup\n  * @param {number} additional_solver_iterations\n  * @returns {number}\n  */\n  _createClass(RawRigidBodySet, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"rbTranslation\",\n    value: function rbTranslation(handle) {\n      var ret = wasm.rawrigidbodyset_rbTranslation(this.__wbg_ptr, handle);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n  }, {\n    key: \"rbRotation\",\n    value: function rbRotation(handle) {\n      var ret = wasm.rawrigidbodyset_rbRotation(this.__wbg_ptr, handle);\n      return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n  }, {\n    key: \"rbSleep\",\n    value: function rbSleep(handle) {\n      wasm.rawrigidbodyset_rbSleep(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"rbIsSleeping\",\n    value: function rbIsSleeping(handle) {\n      var ret = wasm.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"rbIsMoving\",\n    value: function rbIsMoving(handle) {\n      var ret = wasm.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"rbNextTranslation\",\n    value: function rbNextTranslation(handle) {\n      var ret = wasm.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, handle);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n  }, {\n    key: \"rbNextRotation\",\n    value: function rbNextRotation(handle) {\n      var ret = wasm.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, handle);\n      return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbSetTranslation\",\n    value: function rbSetTranslation(handle, x, y, wakeUp) {\n      wasm.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, handle, x, y, wakeUp);\n    }\n    /**\n    * Sets the rotation angle of this rigid-body.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} angle\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbSetRotation\",\n    value: function rbSetRotation(handle, angle, wakeUp) {\n      wasm.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, handle, angle, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbSetLinvel\",\n    value: function rbSetLinvel(handle, linvel, wakeUp) {\n      _assertClass(linvel, RawVector);\n      wasm.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, handle, linvel.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {number} angvel\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbSetAngvel\",\n    value: function rbSetAngvel(handle, angvel, wakeUp) {\n      wasm.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, handle, angvel, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n  }, {\n    key: \"rbSetNextKinematicTranslation\",\n    value: function rbSetNextKinematicTranslation(handle, x, y) {\n      wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * @param {number} handle\n    * @param {number} angle\n    */\n  }, {\n    key: \"rbSetNextKinematicRotation\",\n    value: function rbSetNextKinematicRotation(handle, angle) {\n      wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawColliderSet} colliders\n    */\n  }, {\n    key: \"rbRecomputeMassPropertiesFromColliders\",\n    value: function rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n      _assertClass(colliders, RawColliderSet);\n      wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, handle, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {boolean} wake_up\n    */\n  }, {\n    key: \"rbSetAdditionalMass\",\n    value: function rbSetAdditionalMass(handle, mass, wake_up) {\n      wasm.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, handle, mass, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    * @param {boolean} wake_up\n    */\n  }, {\n    key: \"rbSetAdditionalMassProperties\",\n    value: function rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, wake_up) {\n      _assertClass(centerOfMass, RawVector);\n      wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia, wake_up);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"rbLinvel\",\n    value: function rbLinvel(handle) {\n      var ret = wasm.rawrigidbodyset_rbLinvel(this.__wbg_ptr, handle);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbAngvel\",\n    value: function rbAngvel(handle) {\n      var ret = wasm.rawrigidbodyset_rbAngvel(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n  }, {\n    key: \"rbLockTranslations\",\n    value: function rbLockTranslations(handle, locked, wake_up) {\n      wasm.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} wake_up\n    */\n  }, {\n    key: \"rbSetEnabledTranslations\",\n    value: function rbSetEnabledTranslations(handle, allow_x, allow_y, wake_up) {\n      wasm.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, handle, allow_x, allow_y, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n  }, {\n    key: \"rbLockRotations\",\n    value: function rbLockRotations(handle, locked, wake_up) {\n      wasm.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbDominanceGroup\",\n    value: function rbDominanceGroup(handle) {\n      var ret = wasm.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n  }, {\n    key: \"rbSetDominanceGroup\",\n    value: function rbSetDominanceGroup(handle, group) {\n      wasm.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n  }, {\n    key: \"rbEnableCcd\",\n    value: function rbEnableCcd(handle, enabled) {\n      wasm.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbMass\",\n    value: function rbMass(handle) {\n      var ret = wasm.rawrigidbodyset_rbMass(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The inverse of the mass of a rigid-body.\n    *\n    * If this is zero, the rigid-body is assumed to have infinite mass.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbInvMass\",\n    value: function rbInvMass(handle) {\n      var ret = wasm.rawrigidbodyset_rbInvMass(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The inverse mass taking into account translation locking.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"rbEffectiveInvMass\",\n    value: function rbEffectiveInvMass(handle) {\n      var ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, handle);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * The center of mass of a rigid-body expressed in its local-space.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"rbLocalCom\",\n    value: function rbLocalCom(handle) {\n      var ret = wasm.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, handle);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space center of mass of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"rbWorldCom\",\n    value: function rbWorldCom(handle) {\n      var ret = wasm.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, handle);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * The inverse of the principal angular inertia of the rigid-body.\n    *\n    * Components set to zero are assumed to be infinite along the corresponding principal axis.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbInvPrincipalInertiaSqrt\",\n    value: function rbInvPrincipalInertiaSqrt(handle) {\n      var ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The angular inertia along the principal inertia axes of the rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbPrincipalInertia\",\n    value: function rbPrincipalInertia(handle) {\n      var ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n    * taking into account rotation locking.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbEffectiveWorldInvInertiaSqrt\",\n    value: function rbEffectiveWorldInvInertiaSqrt(handle) {\n      var ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n    * this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbEffectiveAngularInertia\",\n    value: function rbEffectiveAngularInertia(handle) {\n      var ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n  }, {\n    key: \"rbWakeUp\",\n    value: function rbWakeUp(handle) {\n      wasm.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"rbIsCcdEnabled\",\n    value: function rbIsCcdEnabled(handle) {\n      var ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbNumColliders\",\n    value: function rbNumColliders(handle) {\n      var ret = wasm.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, handle);\n      return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n  }, {\n    key: \"rbCollider\",\n    value: function rbCollider(handle, at) {\n      var ret = wasm.rawrigidbodyset_rbCollider(this.__wbg_ptr, handle, at);\n      return ret;\n    }\n    /**\n    * The status of this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {RawRigidBodyType}\n    */\n  }, {\n    key: \"rbBodyType\",\n    value: function rbBodyType(handle) {\n      var ret = wasm.rawrigidbodyset_rbBodyType(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @param {RawRigidBodyType} status\n    * @param {boolean} wake_up\n    */\n  }, {\n    key: \"rbSetBodyType\",\n    value: function rbSetBodyType(handle, status, wake_up) {\n      wasm.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, handle, status, wake_up);\n    }\n    /**\n    * Is this rigid-body fixed?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"rbIsFixed\",\n    value: function rbIsFixed(handle) {\n      var ret = wasm.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"rbIsKinematic\",\n    value: function rbIsKinematic(handle) {\n      var ret = wasm.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"rbIsDynamic\",\n    value: function rbIsDynamic(handle) {\n      var ret = wasm.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbLinearDamping\",\n    value: function rbLinearDamping(handle) {\n      var ret = wasm.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbAngularDamping\",\n    value: function rbAngularDamping(handle) {\n      var ret = wasm.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n  }, {\n    key: \"rbSetLinearDamping\",\n    value: function rbSetLinearDamping(handle, factor) {\n      wasm.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n  }, {\n    key: \"rbSetAngularDamping\",\n    value: function rbSetAngularDamping(handle, factor) {\n      wasm.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n  }, {\n    key: \"rbSetEnabled\",\n    value: function rbSetEnabled(handle, enabled) {\n      wasm.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"rbIsEnabled\",\n    value: function rbIsEnabled(handle) {\n      var ret = wasm.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbGravityScale\",\n    value: function rbGravityScale(handle) {\n      var ret = wasm.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, handle);\n      return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbSetGravityScale\",\n    value: function rbSetGravityScale(handle, factor, wakeUp) {\n      wasm.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added forces added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbResetForces\",\n    value: function rbResetForces(handle, wakeUp) {\n      wasm.rawrigidbodyset_rbResetForces(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added torques added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbResetTorques\",\n    value: function rbResetTorques(handle, wakeUp) {\n      wasm.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Adds a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbAddForce\",\n    value: function rbAddForce(handle, force, wakeUp) {\n      _assertClass(force, RawVector);\n      wasm.rawrigidbodyset_rbAddForce(this.__wbg_ptr, handle, force.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbApplyImpulse\",\n    value: function rbApplyImpulse(handle, impulse, wakeUp) {\n      _assertClass(impulse, RawVector);\n      wasm.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, handle, impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Adds a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {number} torque\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbAddTorque\",\n    value: function rbAddTorque(handle, torque, wakeUp) {\n      wasm.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, handle, torque, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {number} torque_impulse\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbApplyTorqueImpulse\",\n    value: function rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n      wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, handle, torque_impulse, wakeUp);\n    }\n    /**\n    * Adds a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbAddForceAtPoint\",\n    value: function rbAddForceAtPoint(handle, force, point, wakeUp) {\n      _assertClass(force, RawVector);\n      _assertClass(point, RawVector);\n      wasm.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, handle, force.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n  }, {\n    key: \"rbApplyImpulseAtPoint\",\n    value: function rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n      _assertClass(impulse, RawVector);\n      _assertClass(point, RawVector);\n      wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, handle, impulse.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbAdditionalSolverIterations\",\n    value: function rbAdditionalSolverIterations(handle) {\n      var ret = wasm.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, handle);\n      return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} iters\n    */\n  }, {\n    key: \"rbSetAdditionalSolverIterations\",\n    value: function rbSetAdditionalSolverIterations(handle, iters) {\n      wasm.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, handle, iters);\n    }\n    /**\n    * An arbitrary user-defined 32-bit integer\n    * @param {number} handle\n    * @returns {number}\n    */\n  }, {\n    key: \"rbUserData\",\n    value: function rbUserData(handle) {\n      var ret = wasm.rawrigidbodyset_rbUserData(this.__wbg_ptr, handle);\n      return ret >>> 0;\n    }\n    /**\n    * Sets the user-defined 32-bit integer of this rigid-body.\n    *\n    * # Parameters\n    * - `data`: an arbitrary user-defined 32-bit integer.\n    * @param {number} handle\n    * @param {number} data\n    */\n  }, {\n    key: \"rbSetUserData\",\n    value: function rbSetUserData(handle, data) {\n      wasm.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, handle, data);\n    }\n  }, {\n    key: \"createRigidBody\",\n    value: function createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup, additional_solver_iterations) {\n      _assertClass(translation, RawVector);\n      _assertClass(rotation, RawRotation);\n      _assertClass(centerOfMass, RawVector);\n      _assertClass(linvel, RawVector);\n      var ret = wasm.rawrigidbodyset_createRigidBody(this.__wbg_ptr, enabled, translation.__wbg_ptr, rotation.__wbg_ptr, gravityScale, mass, massOnly, centerOfMass.__wbg_ptr, linvel.__wbg_ptr, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup, additional_solver_iterations);\n      return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    */\n  }, {\n    key: \"remove\",\n    value: function remove(handle, islands, colliders, joints, articulations) {\n      _assertClass(islands, RawIslandManager);\n      _assertClass(colliders, RawColliderSet);\n      _assertClass(joints, RawImpulseJointSet);\n      _assertClass(articulations, RawMultibodyJointSet);\n      wasm.rawrigidbodyset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n  }, {\n    key: \"len\",\n    value: function len() {\n      var ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n  }, {\n    key: \"contains\",\n    value: function contains(handle) {\n      var ret = wasm.rawrigidbodyset_contains(this.__wbg_ptr, handle);\n      return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n  }, {\n    key: \"forEachRigidBodyHandle\",\n    value: function forEachRigidBodyHandle(f) {\n      try {\n        wasm.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n      } finally {\n        heap[stack_pointer++] = undefined;\n      }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n  }, {\n    key: \"propagateModifiedBodyPositionsToColliders\",\n    value: function propagateModifiedBodyPositionsToColliders(colliders) {\n      _assertClass(colliders, RawColliderSet);\n      wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawRigidBodySet.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawRigidBodySet;\n}();\n/**\n* A rotation quaternion.\n*/\nvar RawRotation = /*#__PURE__*/function () {\n  function RawRotation() {\n    _classCallCheck(this, RawRotation);\n  }\n  _createClass(RawRotation, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * The identity rotation.\n    * @returns {RawRotation}\n    */\n  }, {\n    key: \"im\",\n    get:\n    /**\n    * The imaginary part of this complex number.\n    * @returns {number}\n    */\n    function get() {\n      var ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * The real part of this complex number.\n    * @returns {number}\n    */\n  }, {\n    key: \"re\",\n    get: function get() {\n      var ret = wasm.rawrotation_re(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * The rotation angle in radians.\n    * @returns {number}\n    */\n  }, {\n    key: \"angle\",\n    get: function get() {\n      var ret = wasm.rawrotation_angle(this.__wbg_ptr);\n      return ret;\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawRotation.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }, {\n    key: \"identity\",\n    value: function identity() {\n      var ret = wasm.rawrotation_identity();\n      return RawRotation.__wrap(ret);\n    }\n    /**\n    * The rotation with thegiven angle.\n    * @param {number} angle\n    * @returns {RawRotation}\n    */\n  }, {\n    key: \"fromAngle\",\n    value: function fromAngle(angle) {\n      var ret = wasm.rawrotation_fromAngle(angle);\n      return RawRotation.__wrap(ret);\n    }\n  }]);\n  return RawRotation;\n}();\n/**\n*/\nvar RawSerializationPipeline = /*#__PURE__*/function () {\n  /**\n  */\n  function RawSerializationPipeline() {\n    _classCallCheck(this, RawSerializationPipeline);\n    var ret = wasm.rawserializationpipeline_new();\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * @param {RawVector} gravity\n  * @param {RawIntegrationParameters} integrationParameters\n  * @param {RawIslandManager} islands\n  * @param {RawBroadPhase} broadPhase\n  * @param {RawNarrowPhase} narrowPhase\n  * @param {RawRigidBodySet} bodies\n  * @param {RawColliderSet} colliders\n  * @param {RawImpulseJointSet} impulse_joints\n  * @param {RawMultibodyJointSet} multibody_joints\n  * @returns {Uint8Array | undefined}\n  */\n  _createClass(RawSerializationPipeline, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n  }, {\n    key: \"serializeAll\",\n    value: function serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n      _assertClass(gravity, RawVector);\n      _assertClass(integrationParameters, RawIntegrationParameters);\n      _assertClass(islands, RawIslandManager);\n      _assertClass(broadPhase, RawBroadPhase);\n      _assertClass(narrowPhase, RawNarrowPhase);\n      _assertClass(bodies, RawRigidBodySet);\n      _assertClass(colliders, RawColliderSet);\n      _assertClass(impulse_joints, RawImpulseJointSet);\n      _assertClass(multibody_joints, RawMultibodyJointSet);\n      var ret = wasm.rawserializationpipeline_serializeAll(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr);\n      return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n  }, {\n    key: \"deserializeAll\",\n    value: function deserializeAll(data) {\n      var ret = wasm.rawserializationpipeline_deserializeAll(this.__wbg_ptr, addHeapObject(data));\n      return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n  }]);\n  return RawSerializationPipeline;\n}();\n/**\n*/\nvar RawShape = /*#__PURE__*/function () {\n  function RawShape() {\n    _classCallCheck(this, RawShape);\n  }\n  _createClass(RawShape, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @returns {RawShape}\n    */\n  }, {\n    key: \"castShape\",\n    value:\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawVector} shapeVel1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {RawVector} shapeVel2\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    function castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi, stop_at_penetration) {\n      _assertClass(shapePos1, RawVector);\n      _assertClass(shapeRot1, RawRotation);\n      _assertClass(shapeVel1, RawVector);\n      _assertClass(shape2, RawShape);\n      _assertClass(shapePos2, RawVector);\n      _assertClass(shapeRot2, RawRotation);\n      _assertClass(shapeVel2, RawVector);\n      var ret = wasm.rawshape_castShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shapeVel1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, shapeVel2.__wbg_ptr, maxToi, stop_at_penetration);\n      return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n  }, {\n    key: \"intersectsShape\",\n    value: function intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n      _assertClass(shapePos1, RawVector);\n      _assertClass(shapeRot1, RawRotation);\n      _assertClass(shape2, RawShape);\n      _assertClass(shapePos2, RawVector);\n      _assertClass(shapeRot2, RawRotation);\n      var ret = wasm.rawshape_intersectsShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n      return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n  }, {\n    key: \"contactShape\",\n    value: function contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n      _assertClass(shapePos1, RawVector);\n      _assertClass(shapeRot1, RawRotation);\n      _assertClass(shape2, RawShape);\n      _assertClass(shapePos2, RawVector);\n      _assertClass(shapeRot2, RawRotation);\n      var ret = wasm.rawshape_contactShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n      return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(shapePos, shapeRot, point) {\n      _assertClass(shapePos, RawVector);\n      _assertClass(shapeRot, RawRotation);\n      _assertClass(point, RawVector);\n      var ret = wasm.rawshape_containsPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr);\n      return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n  }, {\n    key: \"projectPoint\",\n    value: function projectPoint(shapePos, shapeRot, point, solid) {\n      _assertClass(shapePos, RawVector);\n      _assertClass(shapeRot, RawRotation);\n      _assertClass(point, RawVector);\n      var ret = wasm.rawshape_projectPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr, solid);\n      return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n  }, {\n    key: \"intersectsRay\",\n    value: function intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n      _assertClass(shapePos, RawVector);\n      _assertClass(shapeRot, RawRotation);\n      _assertClass(rayOrig, RawVector);\n      _assertClass(rayDir, RawVector);\n      var ret = wasm.rawshape_intersectsRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n      return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n  }, {\n    key: \"castRay\",\n    value: function castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n      _assertClass(shapePos, RawVector);\n      _assertClass(shapeRot, RawRotation);\n      _assertClass(rayOrig, RawVector);\n      _assertClass(rayDir, RawVector);\n      var ret = wasm.rawshape_castRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n      return ret;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n  }, {\n    key: \"castRayAndGetNormal\",\n    value: function castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n      _assertClass(shapePos, RawVector);\n      _assertClass(shapeRot, RawRotation);\n      _assertClass(rayOrig, RawVector);\n      _assertClass(rayDir, RawVector);\n      var ret = wasm.rawshape_castRayAndGetNormal(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n      return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawShape.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }, {\n    key: \"cuboid\",\n    value: function cuboid(hx, hy) {\n      var ret = wasm.rawshape_cuboid(hx, hy);\n      return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n  }, {\n    key: \"roundCuboid\",\n    value: function roundCuboid(hx, hy, borderRadius) {\n      var ret = wasm.rawshape_roundCuboid(hx, hy, borderRadius);\n      return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n  }, {\n    key: \"ball\",\n    value: function ball(radius) {\n      var ret = wasm.rawshape_ball(radius);\n      return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} normal\n    * @returns {RawShape}\n    */\n  }, {\n    key: \"halfspace\",\n    value: function halfspace(normal) {\n      _assertClass(normal, RawVector);\n      var ret = wasm.rawshape_halfspace(normal.__wbg_ptr);\n      return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n  }, {\n    key: \"capsule\",\n    value: function capsule(halfHeight, radius) {\n      var ret = wasm.rawshape_capsule(halfHeight, radius);\n      return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n  }, {\n    key: \"polyline\",\n    value: function polyline(vertices, indices) {\n      var ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n      var len0 = WASM_VECTOR_LEN;\n      var ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n      var len1 = WASM_VECTOR_LEN;\n      var ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n      return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n  }, {\n    key: \"trimesh\",\n    value: function trimesh(vertices, indices) {\n      var ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n      var len0 = WASM_VECTOR_LEN;\n      var ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n      var len1 = WASM_VECTOR_LEN;\n      var ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1);\n      return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @returns {RawShape}\n    */\n  }, {\n    key: \"heightfield\",\n    value: function heightfield(heights, scale) {\n      var ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n      var len0 = WASM_VECTOR_LEN;\n      _assertClass(scale, RawVector);\n      var ret = wasm.rawshape_heightfield(ptr0, len0, scale.__wbg_ptr);\n      return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n  }, {\n    key: \"segment\",\n    value: function segment(p1, p2) {\n      _assertClass(p1, RawVector);\n      _assertClass(p2, RawVector);\n      var ret = wasm.rawshape_segment(p1.__wbg_ptr, p2.__wbg_ptr);\n      return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n  }, {\n    key: \"triangle\",\n    value: function triangle(p1, p2, p3) {\n      _assertClass(p1, RawVector);\n      _assertClass(p2, RawVector);\n      _assertClass(p3, RawVector);\n      var ret = wasm.rawshape_triangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr);\n      return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n  }, {\n    key: \"roundTriangle\",\n    value: function roundTriangle(p1, p2, p3, borderRadius) {\n      _assertClass(p1, RawVector);\n      _assertClass(p2, RawVector);\n      _assertClass(p3, RawVector);\n      var ret = wasm.rawshape_roundTriangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr, borderRadius);\n      return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n  }, {\n    key: \"convexHull\",\n    value: function convexHull(points) {\n      var ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n      var len0 = WASM_VECTOR_LEN;\n      var ret = wasm.rawshape_convexHull(ptr0, len0);\n      return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n  }, {\n    key: \"roundConvexHull\",\n    value: function roundConvexHull(points, borderRadius) {\n      var ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n      var len0 = WASM_VECTOR_LEN;\n      var ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n      return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @returns {RawShape | undefined}\n    */\n  }, {\n    key: \"convexPolyline\",\n    value: function convexPolyline(vertices) {\n      var ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n      var len0 = WASM_VECTOR_LEN;\n      var ret = wasm.rawshape_convexPolyline(ptr0, len0);\n      return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n  }, {\n    key: \"roundConvexPolyline\",\n    value: function roundConvexPolyline(vertices, borderRadius) {\n      var ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n      var len0 = WASM_VECTOR_LEN;\n      var ret = wasm.rawshape_roundConvexPolyline(ptr0, len0, borderRadius);\n      return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n  }]);\n  return RawShape;\n}();\n/**\n*/\nvar RawShapeColliderTOI = /*#__PURE__*/function () {\n  function RawShapeColliderTOI() {\n    _classCallCheck(this, RawShapeColliderTOI);\n  }\n  _createClass(RawShapeColliderTOI, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawshapecollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"colliderHandle\",\n    value: function colliderHandle() {\n      var ret = wasm.rawcontactforceevent_collider1(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"toi\",\n    value: function toi() {\n      var ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"witness1\",\n    value: function witness1() {\n      var ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"witness2\",\n    value: function witness2() {\n      var ret = wasm.rawshapecollidertoi_witness2(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"normal1\",\n    value: function normal1() {\n      var ret = wasm.rawshapecollidertoi_normal1(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"normal2\",\n    value: function normal2() {\n      var ret = wasm.rawkinematiccharactercontroller_up(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawShapeColliderTOI.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawShapeColliderTOI;\n}();\n/**\n*/\nvar RawShapeContact = /*#__PURE__*/function () {\n  function RawShapeContact() {\n    _classCallCheck(this, RawShapeContact);\n  }\n  _createClass(RawShapeContact, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawshapecontact_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"distance\",\n    value: function distance() {\n      var ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"point1\",\n    value: function point1() {\n      var ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"point2\",\n    value: function point2() {\n      var ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"normal1\",\n    value: function normal1() {\n      var ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"normal2\",\n    value: function normal2() {\n      var ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawShapeContact.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawShapeContact;\n}();\n/**\n*/\nvar RawShapeTOI = /*#__PURE__*/function () {\n  function RawShapeTOI() {\n    _classCallCheck(this, RawShapeTOI);\n  }\n  _createClass(RawShapeTOI, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawshapetoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n  }, {\n    key: \"toi\",\n    value: function toi() {\n      var ret = wasm.rawrotation_re(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"witness1\",\n    value: function witness1() {\n      var ret = wasm.rawshapetoi_witness1(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"witness2\",\n    value: function witness2() {\n      var ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"normal1\",\n    value: function normal1() {\n      var ret = wasm.rawshapecollidertoi_witness2(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"normal2\",\n    value: function normal2() {\n      var ret = wasm.rawshapecollidertoi_normal1(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawShapeTOI.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }]);\n  return RawShapeTOI;\n}();\n/**\n* A vector.\n*/\nvar RawVector = /*#__PURE__*/function () {\n  /**\n  * Creates a new 2D vector from its two components.\n  *\n  * # Parameters\n  * - `x`: the `x` component of this 2D vector.\n  * - `y`: the `y` component of this 2D vector.\n  * @param {number} x\n  * @param {number} y\n  */\n  function RawVector(x, y) {\n    _classCallCheck(this, RawVector);\n    var ret = wasm.rawvector_new(x, y);\n    this.__wbg_ptr = ret >>> 0;\n    return this;\n  }\n  /**\n  * The `x` component of this vector.\n  * @returns {number}\n  */\n  _createClass(RawVector, [{\n    key: \"__destroy_into_raw\",\n    value: function __destroy_into_raw() {\n      var ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      return ptr;\n    }\n  }, {\n    key: \"free\",\n    value: function free() {\n      var ptr = this.__destroy_into_raw();\n      wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"x\",\n    get: function get() {\n      var ret = wasm.rawrotation_re(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */,\n    set: function set(x) {\n      wasm.rawvector_set_x(this.__wbg_ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n  }, {\n    key: \"y\",\n    get: function get() {\n      var ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n      return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */,\n    set: function set(y) {\n      wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, y);\n    }\n    /**\n    * Create a new 2D vector from this vector with its components rearranged as `{x, y}`.\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"xy\",\n    value: function xy() {\n      var ret = wasm.rawvector_xy(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 2D vector from this vector with its components rearranged as `{y, x}`.\n    * @returns {RawVector}\n    */\n  }, {\n    key: \"yx\",\n    value: function yx() {\n      var ret = wasm.rawvector_yx(this.__wbg_ptr);\n      return RawVector.__wrap(ret);\n    }\n  }], [{\n    key: \"__wrap\",\n    value: function __wrap(ptr) {\n      ptr = ptr >>> 0;\n      var obj = Object.create(RawVector.prototype);\n      obj.__wbg_ptr = ptr;\n      return obj;\n    }\n  }, {\n    key: \"zero\",\n    value: function zero() {\n      var ret = wasm.rawvector_zero();\n      return RawVector.__wrap(ret);\n    }\n  }]);\n  return RawVector;\n}();\nfunction __wbindgen_number_new(arg0) {\n  var ret = arg0;\n  return addHeapObject(ret);\n}\n;\nfunction __wbindgen_boolean_get(arg0) {\n  var v = getObject(arg0);\n  var ret = typeof v === 'boolean' ? v ? 1 : 0 : 2;\n  return ret;\n}\n;\nfunction __wbindgen_object_drop_ref(arg0) {\n  takeObject(arg0);\n}\n;\nfunction __wbindgen_number_get(arg0, arg1) {\n  var obj = getObject(arg1);\n  var ret = typeof obj === 'number' ? obj : undefined;\n  getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n  getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n}\n;\nfunction __wbindgen_is_function(arg0) {\n  var ret = typeof getObject(arg0) === 'function';\n  return ret;\n}\n;\nfunction __wbg_rawraycolliderintersection_new(arg0) {\n  var ret = RawRayColliderIntersection.__wrap(arg0);\n  return addHeapObject(ret);\n}\n;\nfunction __wbg_rawcontactforceevent_new(arg0) {\n  var ret = RawContactForceEvent.__wrap(arg0);\n  return addHeapObject(ret);\n}\n;\nfunction __wbg_call_01734de55d61e11d() {\n  return handleError(function (arg0, arg1, arg2) {\n    var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n  }, arguments);\n}\n;\nfunction __wbg_call_4c92f6aec1e1d6e6() {\n  return handleError(function (arg0, arg1, arg2, arg3) {\n    var ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n  }, arguments);\n}\n;\nfunction __wbg_call_776890ca77946e2f() {\n  return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    var ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n  }, arguments);\n}\n;\nfunction __wbg_bind_60a9a80cada2f33c(arg0, arg1, arg2, arg3) {\n  var ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n  return addHeapObject(ret);\n}\n;\nfunction __wbg_buffer_085ec1f694018c4f(arg0) {\n  var ret = getObject(arg0).buffer;\n  return addHeapObject(ret);\n}\n;\nfunction __wbg_newwithbyteoffsetandlength_6da8e527659b86aa(arg0, arg1, arg2) {\n  var ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n  return addHeapObject(ret);\n}\n;\nfunction __wbg_new_8125e318e6245eed(arg0) {\n  var ret = new Uint8Array(getObject(arg0));\n  return addHeapObject(ret);\n}\n;\nfunction __wbg_set_5cf90238115182c3(arg0, arg1, arg2) {\n  getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n}\n;\nfunction __wbg_length_72e2208bbc0efc61(arg0) {\n  var ret = getObject(arg0).length;\n  return ret;\n}\n;\nfunction __wbg_newwithbyteoffsetandlength_69193e31c844b792(arg0, arg1, arg2) {\n  var ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n  return addHeapObject(ret);\n}\n;\nfunction __wbg_set_6146c51d49a2c0df(arg0, arg1, arg2) {\n  getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n}\n;\nfunction __wbg_length_d7327c75a759af37(arg0) {\n  var ret = getObject(arg0).length;\n  return ret;\n}\n;\nfunction __wbg_newwithlength_68d29ab115d0099c(arg0) {\n  var ret = new Float32Array(arg0 >>> 0);\n  return addHeapObject(ret);\n}\n;\nfunction __wbindgen_throw(arg0, arg1) {\n  throw new Error(getStringFromWasm0(arg0, arg1));\n}\n;\nfunction __wbindgen_memory() {\n  var ret = wasm.memory;\n  return addHeapObject(ret);\n}\n;\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.wasm":
/*!***************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.wasm ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./rapier_wasm2d_bg.js */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js\");\nmodule.exports = __webpack_require__.v(exports, module.id, \"130c0677770ae14226c3\", {\n\t\"./rapier_wasm2d_bg.js\": {\n\t\t\"__wbindgen_number_new\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_number_new,\n\t\t\"__wbindgen_boolean_get\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_boolean_get,\n\t\t\"__wbindgen_object_drop_ref\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_drop_ref,\n\t\t\"__wbindgen_number_get\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_number_get,\n\t\t\"__wbindgen_is_function\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_function,\n\t\t\"__wbg_rawraycolliderintersection_new\": WEBPACK_IMPORTED_MODULE_0.__wbg_rawraycolliderintersection_new,\n\t\t\"__wbg_rawcontactforceevent_new\": WEBPACK_IMPORTED_MODULE_0.__wbg_rawcontactforceevent_new,\n\t\t\"__wbg_call_01734de55d61e11d\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_01734de55d61e11d,\n\t\t\"__wbg_call_4c92f6aec1e1d6e6\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_4c92f6aec1e1d6e6,\n\t\t\"__wbg_call_776890ca77946e2f\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_776890ca77946e2f,\n\t\t\"__wbg_bind_60a9a80cada2f33c\": WEBPACK_IMPORTED_MODULE_0.__wbg_bind_60a9a80cada2f33c,\n\t\t\"__wbg_buffer_085ec1f694018c4f\": WEBPACK_IMPORTED_MODULE_0.__wbg_buffer_085ec1f694018c4f,\n\t\t\"__wbg_newwithbyteoffsetandlength_6da8e527659b86aa\": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithbyteoffsetandlength_6da8e527659b86aa,\n\t\t\"__wbg_new_8125e318e6245eed\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_8125e318e6245eed,\n\t\t\"__wbg_set_5cf90238115182c3\": WEBPACK_IMPORTED_MODULE_0.__wbg_set_5cf90238115182c3,\n\t\t\"__wbg_length_72e2208bbc0efc61\": WEBPACK_IMPORTED_MODULE_0.__wbg_length_72e2208bbc0efc61,\n\t\t\"__wbg_newwithbyteoffsetandlength_69193e31c844b792\": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithbyteoffsetandlength_69193e31c844b792,\n\t\t\"__wbg_set_6146c51d49a2c0df\": WEBPACK_IMPORTED_MODULE_0.__wbg_set_6146c51d49a2c0df,\n\t\t\"__wbg_length_d7327c75a759af37\": WEBPACK_IMPORTED_MODULE_0.__wbg_length_d7327c75a759af37,\n\t\t\"__wbg_newwithlength_68d29ab115d0099c\": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithlength_68d29ab115d0099c,\n\t\t\"__wbindgen_throw\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_throw,\n\t\t\"__wbindgen_memory\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_memory\n\t}\n});\n\n//# sourceURL=webpack://general-interface/./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.wasm?");

/***/ })

}]);